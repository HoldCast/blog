{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia2/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia2/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"source/assets/img/favicon.ico","path":"assets/img/favicon.ico","modified":1,"renderable":0},{"_id":"source/assets/img/header.png","path":"assets/img/header.png","modified":1,"renderable":0},{"_id":"source/assets/img/http-lc.png","path":"assets/img/http-lc.png","modified":1,"renderable":0},{"_id":"source/assets/img/log.jpg","path":"assets/img/log.jpg","modified":1,"renderable":0},{"_id":"themes/yilia2/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"source/assets/img/bootstrapMetro.png","path":"assets/img/bootstrapMetro.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia2/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1511167291832},{"_id":"themes/yilia2/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1511167291833},{"_id":"themes/yilia2/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1511167291834},{"_id":"themes/yilia2/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1511167291835},{"_id":"themes/yilia2/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1511167291837},{"_id":"source/_posts/JavaScript - 类型判断.md","hash":"4797f230db00a4496686770bfc5906832d4ca8e9","modified":1512094071247},{"_id":"source/_posts/hello-world.md","hash":"28f06ab29250ebc6d626bfd792e3f098bcb0156e","modified":1511148494472},{"_id":"themes/yilia2/_config.yml","hash":"0c669187283220f90e76e83f968d49866422b467","modified":1511318920819},{"_id":"source/_posts/bootstrap-metro.md","hash":"690ca47436166c2b551768413e60615ae3ed9677","modified":1511257124383},{"_id":"source/_posts/http-headers.md","hash":"68b70dc214c74055a2b1d4e576afb2efdcbdb4b1","modified":1511939802298},{"_id":"source/menu/index.md","hash":"5abb6b491f1ef355543649f667d917b76c6c01f3","modified":1510977905372},{"_id":"source/_posts/http-status.md","hash":"4b8c02ea2f0cfada7c141d73b57051eab3a4a6c6","modified":1511939708792},{"_id":"themes/yilia2/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1511167291871},{"_id":"themes/yilia2/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1511167291931},{"_id":"source/_posts/responseLayout.md","hash":"ed4146301a207ed68d383cc08cfd093514383db9","modified":1511488256836},{"_id":"source/_posts/http.md","hash":"37a76a076deb2af8a0ad8dd58029500323506317","modified":1511947317803},{"_id":"themes/yilia2/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1511167291867},{"_id":"source/public/2.md","hash":"b1017ab1177d72528be39841a24e2f9f459b2b36","modified":1511158899368},{"_id":"themes/yilia2/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1511167291866},{"_id":"themes/yilia2/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1511167291869},{"_id":"themes/yilia2/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1511167291867},{"_id":"source/public/index.md","hash":"7770b8a8592fa9f99a0effa058548d8888c7d4f6","modified":1511158833929},{"_id":"themes/yilia2/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1511167291868},{"_id":"themes/yilia2/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1511167291870},{"_id":"themes/yilia2/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1511167291870},{"_id":"themes/yilia2/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1511167291930},{"_id":"themes/yilia2/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1511167291840},{"_id":"themes/yilia2/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1511167291839},{"_id":"themes/yilia2/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1511167291841},{"_id":"themes/yilia2/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1511167291841},{"_id":"themes/yilia2/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1511167291843},{"_id":"themes/yilia2/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1511167291842},{"_id":"themes/yilia2/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1511167291843},{"_id":"themes/yilia2/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1511167291926},{"_id":"themes/yilia2/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1511167291872},{"_id":"source/tags/index.md","hash":"bdafbe532f736e3596f0c5b7952fea4029bf5af2","modified":1511147956329},{"_id":"themes/yilia2/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1511167291864},{"_id":"themes/yilia2/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1511167291928},{"_id":"themes/yilia2/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1511167291929},{"_id":"themes/yilia2/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1511167291916},{"_id":"source/assets/img/favicon.ico","hash":"d33cddcbbbbb16c1c1fed6d40f23097a27708adf","modified":1510979210542},{"_id":"source/assets/img/header.png","hash":"e4eea11e1656950b44ddb6c736b74688ea874ac2","modified":1511428733617},{"_id":"source/assets/img/http-lc.png","hash":"9df27f26ae5cca68ff1fe817ab6c122a33b8f9d3","modified":1511941161811},{"_id":"themes/yilia2/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1511167291846},{"_id":"themes/yilia2/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1511167291845},{"_id":"themes/yilia2/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1511167291846},{"_id":"themes/yilia2/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1511167291848},{"_id":"themes/yilia2/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1511167291849},{"_id":"themes/yilia2/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1511167291850},{"_id":"themes/yilia2/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1511167291851},{"_id":"themes/yilia2/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1511167291851},{"_id":"source/assets/img/log.jpg","hash":"c0078e8d9ab23f187652865b67431ceb99d46c97","modified":1510979064936},{"_id":"themes/yilia2/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1511167291853},{"_id":"themes/yilia2/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1511167291854},{"_id":"themes/yilia2/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1511167291848},{"_id":"themes/yilia2/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1511167291854},{"_id":"themes/yilia2/layout/_partial/article.ejs","hash":"8dea8f5f93a60185439b330b0f1d1649a6ab4bd0","modified":1511167291847},{"_id":"themes/yilia2/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1511167291865},{"_id":"themes/yilia2/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1511167291865},{"_id":"themes/yilia2/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1511167291852},{"_id":"themes/yilia2/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1511167291919},{"_id":"themes/yilia2/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1511167291924},{"_id":"themes/yilia2/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1511167291918},{"_id":"themes/yilia2/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1511167291925},{"_id":"themes/yilia2/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1511167291921},{"_id":"themes/yilia2/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1511167291923},{"_id":"themes/yilia2/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1511167291925},{"_id":"themes/yilia2/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1511167291918},{"_id":"themes/yilia2/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1511167291907},{"_id":"themes/yilia2/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1511167291909},{"_id":"themes/yilia2/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1511167291909},{"_id":"themes/yilia2/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1511167291911},{"_id":"themes/yilia2/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1511167291912},{"_id":"themes/yilia2/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1511167291913},{"_id":"themes/yilia2/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1511167291908},{"_id":"themes/yilia2/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1511167291910},{"_id":"themes/yilia2/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1511167291920},{"_id":"themes/yilia2/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1511167291915},{"_id":"themes/yilia2/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1511167291873},{"_id":"themes/yilia2/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1511167291914},{"_id":"themes/yilia2/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1511167291913},{"_id":"themes/yilia2/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1511167291915},{"_id":"themes/yilia2/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1511167291874},{"_id":"themes/yilia2/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1511167291877},{"_id":"themes/yilia2/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1511167291875},{"_id":"themes/yilia2/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1511167291879},{"_id":"themes/yilia2/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1511167291880},{"_id":"themes/yilia2/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1511167291876},{"_id":"themes/yilia2/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1511167291876},{"_id":"themes/yilia2/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1511167291879},{"_id":"themes/yilia2/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1511167291886},{"_id":"themes/yilia2/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1511167291890},{"_id":"themes/yilia2/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1511167291891},{"_id":"themes/yilia2/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1511167291892},{"_id":"themes/yilia2/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1511167291896},{"_id":"themes/yilia2/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1511167291895},{"_id":"themes/yilia2/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1511167291899},{"_id":"themes/yilia2/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1511167291897},{"_id":"themes/yilia2/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1511167291898},{"_id":"themes/yilia2/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1511167291902},{"_id":"themes/yilia2/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1511167291899},{"_id":"themes/yilia2/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1511167291902},{"_id":"themes/yilia2/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1511167291904},{"_id":"themes/yilia2/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1511167291905},{"_id":"themes/yilia2/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1511167291900},{"_id":"source/assets/img/bootstrapMetro.png","hash":"2be5346ac6927f87f9cc951435041f44ad90a402","modified":1511246934856},{"_id":"themes/yilia2/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1511167291863},{"_id":"themes/yilia2/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1511167291855},{"_id":"themes/yilia2/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1511167291856},{"_id":"themes/yilia2/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1511167291857},{"_id":"themes/yilia2/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1511167291892},{"_id":"themes/yilia2/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1511167291858},{"_id":"themes/yilia2/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1511167291859},{"_id":"themes/yilia2/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1511167291903},{"_id":"themes/yilia2/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1511167291861},{"_id":"themes/yilia2/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1511167291861},{"_id":"themes/yilia2/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1511167291862},{"_id":"themes/yilia2/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1511167291906},{"_id":"themes/yilia2/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1511167291860},{"_id":"themes/yilia2/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1511167291881},{"_id":"themes/yilia2/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1511167291883},{"_id":"themes/yilia2/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1511167291882},{"_id":"themes/yilia2/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1511167291858},{"_id":"themes/yilia2/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1511167291885},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1511167291887},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1511167291888},{"_id":"themes/yilia2/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1511167291893},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1511167291889},{"_id":"themes/yilia2/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1511167291895},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1511167291890},{"_id":"themes/yilia2/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1511167291884},{"_id":"themes/yilia2/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1511167291894}],"Category":[],"Data":[],"Page":[{"title":"menu","_content":"","source":"menu/index.md","raw":"---\ntitle: menu\n---","date":"2017-11-20T02:21:44.644Z","updated":"2017-11-18T04:05:05.372Z","path":"menu/index.html","comments":1,"layout":"page","_id":"cjan9rqaa000110tokkh1a6hx","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"2222222222","source":"public/2.md","raw":"2222222222","date":"2017-11-20T06:21:39.419Z","updated":"2017-11-20T06:21:39.368Z","path":"public/2.html","title":"","comments":1,"layout":"page","_id":"cjan9rqbh000t10tosyibsn4x","content":"<p>2222222222</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2222222222</p>\n"},{"_content":"title: public\ntags:\n  - public","source":"public/index.md","raw":"title: public\ntags:\n  - public","date":"2017-11-20T06:20:33.957Z","updated":"2017-11-20T06:20:33.929Z","path":"public/index.html","title":"","comments":1,"layout":"page","_id":"cjan9rqbk000v10tor4zqpi2o","content":"<p>title: public<br>tags:</p>\n<ul>\n<li>public</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>title: public<br>tags:</p>\n<ul>\n<li>public</li>\n</ul>\n"},{"title":"tags","date":"2015-12-02T04:10:34.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-12-02 12:10:34\ntype: \"tags\"\n---","updated":"2017-11-20T03:19:16.329Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjan9rqbm000x10toto8pnx6m","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JavaScript - 对象类型判断","_content":"- typeof 判断\n- instanceof 运算符\n- constructor 属性\n- Object.prototype.toString() 判断\n\n<!-- more -->\n### 1.typeof 判断\n在区别对象和原始类型的时候可使用这种判断方法,其返回值有:\"number\"，\"string\"，\"boolean\"，\"object\"，\"function\"，\"undefined\"（可用于判断变量是否存在）.\n但typeof有局限，其对于null、{}、[]、Date、RegExp等类型返回的都是\"object\"。如：\ntypeof {}; // object\ntypeof []; // object\ntypeof null; // object\ntypeof new Date(); // object;\n\n### 2.instanceof 运算符\ninstanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。\n如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。如：\n[] instanceof Array; // true\n[] instanceof Object; // true\n[] instanceof RegExp; // false\nnew Date instanceof Date; // true\n *可以用instanceof运算符来判断对象是否为数组类型.*\n\n### 3.constructor 属性\nJavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。\n通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。所以判断数组的函数也可以这样写：\nfunction isArray(arr){\n  return typeof arr == \"object\" && arr.constructor == Array;\n}\n\n### 4.Object.prototype.toString() 判断\n** \\*这种方法可以准确判断各种数据类型\\* **\nObject.prototype.toString.call([]); // \"[object Array]\"\nObject.prototype.toString.call(/reg/ig); // \"[object RegExp]\"\nObject.prototype.toString.call(999); // \"[object Number]\"\n用于检测各种对象类型：\n```\nvar is ={\n  types : [\"Array\", \"Boolean\", \"Date\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Window\", \"HTMLDocument\"]\n};\nfor(var i = 0, c; c = is.types[i ++ ]; ){\n  is[c] = (function(type){\n    return function(obj){\n      return Object.prototype.toString.call(obj) == \"[object \" + type + \"]\";\n    }\n  )(c);\n}\nalert(is.Array([])); // true\nalert(is.Date(new Date)); // true\nalert(is.RegExp(/reg/ig)); // true\n//...\n```","source":"_posts/JavaScript - 类型判断.md","raw":"title: JavaScript - 对象类型判断\ntags:\n    - javascript\n    - 类型判断\n---\n- typeof 判断\n- instanceof 运算符\n- constructor 属性\n- Object.prototype.toString() 判断\n\n<!-- more -->\n### 1.typeof 判断\n在区别对象和原始类型的时候可使用这种判断方法,其返回值有:\"number\"，\"string\"，\"boolean\"，\"object\"，\"function\"，\"undefined\"（可用于判断变量是否存在）.\n但typeof有局限，其对于null、{}、[]、Date、RegExp等类型返回的都是\"object\"。如：\ntypeof {}; // object\ntypeof []; // object\ntypeof null; // object\ntypeof new Date(); // object;\n\n### 2.instanceof 运算符\ninstanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。\n如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。如：\n[] instanceof Array; // true\n[] instanceof Object; // true\n[] instanceof RegExp; // false\nnew Date instanceof Date; // true\n *可以用instanceof运算符来判断对象是否为数组类型.*\n\n### 3.constructor 属性\nJavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。\n通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。所以判断数组的函数也可以这样写：\nfunction isArray(arr){\n  return typeof arr == \"object\" && arr.constructor == Array;\n}\n\n### 4.Object.prototype.toString() 判断\n** \\*这种方法可以准确判断各种数据类型\\* **\nObject.prototype.toString.call([]); // \"[object Array]\"\nObject.prototype.toString.call(/reg/ig); // \"[object RegExp]\"\nObject.prototype.toString.call(999); // \"[object Number]\"\n用于检测各种对象类型：\n```\nvar is ={\n  types : [\"Array\", \"Boolean\", \"Date\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Window\", \"HTMLDocument\"]\n};\nfor(var i = 0, c; c = is.types[i ++ ]; ){\n  is[c] = (function(type){\n    return function(obj){\n      return Object.prototype.toString.call(obj) == \"[object \" + type + \"]\";\n    }\n  )(c);\n}\nalert(is.Array([])); // true\nalert(is.Date(new Date)); // true\nalert(is.RegExp(/reg/ig)); // true\n//...\n```","slug":"JavaScript - 类型判断","published":1,"date":"2017-12-01T03:13:29.847Z","updated":"2017-12-01T03:13:29.848Z","_id":"cjan9rq9p000010totfutit0z","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>typeof 判断</li>\n<li>instanceof 运算符</li>\n<li>constructor 属性</li>\n<li>Object.prototype.toString() 判断</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"1-typeof-判断\"><a href=\"#1-typeof-判断\" class=\"headerlink\" title=\"1.typeof 判断\"></a>1.typeof 判断</h3><p>在区别对象和原始类型的时候可使用这种判断方法,其返回值有:”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）.<br>但typeof有局限，其对于null、{}、[]、Date、RegExp等类型返回的都是”object”。如：<br>typeof {}; // object<br>typeof []; // object<br>typeof null; // object<br>typeof new Date(); // object;</p>\n<h3 id=\"2-instanceof-运算符\"><a href=\"#2-instanceof-运算符\" class=\"headerlink\" title=\"2.instanceof 运算符\"></a>2.instanceof 运算符</h3><p>instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。<br>如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。如：<br>[] instanceof Array; // true<br>[] instanceof Object; // true<br>[] instanceof RegExp; // false<br>new Date instanceof Date; // true<br> <em>可以用instanceof运算符来判断对象是否为数组类型.</em></p>\n<h3 id=\"3-constructor-属性\"><a href=\"#3-constructor-属性\" class=\"headerlink\" title=\"3.constructor 属性\"></a>3.constructor 属性</h3><p>JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。<br>通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。所以判断数组的函数也可以这样写：<br>function isArray(arr){<br>  return typeof arr == “object” &amp;&amp; arr.constructor == Array;<br>}</p>\n<h3 id=\"4-Object-prototype-toString-判断\"><a href=\"#4-Object-prototype-toString-判断\" class=\"headerlink\" title=\"4.Object.prototype.toString() 判断\"></a>4.Object.prototype.toString() 判断</h3><p><strong> *这种方法可以准确判断各种数据类型* </strong><br>Object.prototype.toString.call([]); // “[object Array]”<br>Object.prototype.toString.call(/reg/ig); // “[object RegExp]”<br>Object.prototype.toString.call(999); // “[object Number]”<br>用于检测各种对象类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var is =&#123;</span><br><span class=\"line\">  types : [&quot;Array&quot;, &quot;Boolean&quot;, &quot;Date&quot;, &quot;Number&quot;, &quot;Object&quot;, &quot;RegExp&quot;, &quot;String&quot;, &quot;Window&quot;, &quot;HTMLDocument&quot;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">for(var i = 0, c; c = is.types[i ++ ]; )&#123;</span><br><span class=\"line\">  is[c] = (function(type)&#123;</span><br><span class=\"line\">    return function(obj)&#123;</span><br><span class=\"line\">      return Object.prototype.toString.call(obj) == &quot;[object &quot; + type + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(is.Array([])); // true</span><br><span class=\"line\">alert(is.Date(new Date)); // true</span><br><span class=\"line\">alert(is.RegExp(/reg/ig)); // true</span><br><span class=\"line\">//...</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>typeof 判断</li>\n<li>instanceof 运算符</li>\n<li>constructor 属性</li>\n<li>Object.prototype.toString() 判断</li>\n</ul>","more":"<h3 id=\"1-typeof-判断\"><a href=\"#1-typeof-判断\" class=\"headerlink\" title=\"1.typeof 判断\"></a>1.typeof 判断</h3><p>在区别对象和原始类型的时候可使用这种判断方法,其返回值有:”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）.<br>但typeof有局限，其对于null、{}、[]、Date、RegExp等类型返回的都是”object”。如：<br>typeof {}; // object<br>typeof []; // object<br>typeof null; // object<br>typeof new Date(); // object;</p>\n<h3 id=\"2-instanceof-运算符\"><a href=\"#2-instanceof-运算符\" class=\"headerlink\" title=\"2.instanceof 运算符\"></a>2.instanceof 运算符</h3><p>instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。<br>如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。如：<br>[] instanceof Array; // true<br>[] instanceof Object; // true<br>[] instanceof RegExp; // false<br>new Date instanceof Date; // true<br> <em>可以用instanceof运算符来判断对象是否为数组类型.</em></p>\n<h3 id=\"3-constructor-属性\"><a href=\"#3-constructor-属性\" class=\"headerlink\" title=\"3.constructor 属性\"></a>3.constructor 属性</h3><p>JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。<br>通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。所以判断数组的函数也可以这样写：<br>function isArray(arr){<br>  return typeof arr == “object” &amp;&amp; arr.constructor == Array;<br>}</p>\n<h3 id=\"4-Object-prototype-toString-判断\"><a href=\"#4-Object-prototype-toString-判断\" class=\"headerlink\" title=\"4.Object.prototype.toString() 判断\"></a>4.Object.prototype.toString() 判断</h3><p><strong> *这种方法可以准确判断各种数据类型* </strong><br>Object.prototype.toString.call([]); // “[object Array]”<br>Object.prototype.toString.call(/reg/ig); // “[object RegExp]”<br>Object.prototype.toString.call(999); // “[object Number]”<br>用于检测各种对象类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var is =&#123;</span><br><span class=\"line\">  types : [&quot;Array&quot;, &quot;Boolean&quot;, &quot;Date&quot;, &quot;Number&quot;, &quot;Object&quot;, &quot;RegExp&quot;, &quot;String&quot;, &quot;Window&quot;, &quot;HTMLDocument&quot;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">for(var i = 0, c; c = is.types[i ++ ]; )&#123;</span><br><span class=\"line\">  is[c] = (function(type)&#123;</span><br><span class=\"line\">    return function(obj)&#123;</span><br><span class=\"line\">      return Object.prototype.toString.call(obj) == &quot;[object &quot; + type + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(is.Array([])); // true</span><br><span class=\"line\">alert(is.Date(new Date)); // true</span><br><span class=\"line\">alert(is.RegExp(/reg/ig)); // true</span><br><span class=\"line\">//...</span><br></pre></td></tr></table></figure></p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags:\n  - guide\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-11-20T03:28:14.471Z","updated":"2017-11-20T03:28:14.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjan9rqac000210tofo0ugao5","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"Bootstrap-Metro后台管理模板","_content":"![](/assets/img/bootstrapMetro.png)\n---\n[【查看演示】](https://holdcast.github.io/metro/)[【源码下载】](https://github.com/HoldCast/metro)[【官方文档】](http://www.bootcss.com/p/metro-ui-css/index.html)","source":"_posts/bootstrap-metro.md","raw":"title: Bootstrap-Metro后台管理模板\ntags:\n  - bootstrap\n  - 响应式\n  - metro\n---\n![](/assets/img/bootstrapMetro.png)\n---\n[【查看演示】](https://holdcast.github.io/metro/)[【源码下载】](https://github.com/HoldCast/metro)[【官方文档】](http://www.bootcss.com/p/metro-ui-css/index.html)","slug":"bootstrap-metro","published":1,"date":"2017-11-21T09:38:44.378Z","updated":"2017-11-21T09:38:44.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjan9rqaj000410tobfa8adbd","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/assets/img/bootstrapMetro.png\" alt=\"\"></h2><p><a href=\"https://holdcast.github.io/metro/\">【查看演示】</a><a href=\"https://github.com/HoldCast/metro\" target=\"_blank\" rel=\"noopener\">【源码下载】</a><a href=\"http://www.bootcss.com/p/metro-ui-css/index.html\" target=\"_blank\" rel=\"noopener\">【官方文档】</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/assets/img/bootstrapMetro.png\" alt=\"\"></h2><p><a href=\"https://holdcast.github.io/metro/\">【查看演示】</a><a href=\"https://github.com/HoldCast/metro\" target=\"_blank\" rel=\"noopener\">【源码下载】</a><a href=\"http://www.bootcss.com/p/metro-ui-css/index.html\" target=\"_blank\" rel=\"noopener\">【官方文档】</a></p>\n"},{"title":"前端获取服务器时间及其他Headers信息","_content":"前端页面访问服务器时,获取服务器返回的http请求回来的header信息,如下图:\n![](/assets/img/header.png)\n获取Response Header的方法:\n<!-- more -->\n1.js-ajax方法获取:\n```\nfunction ajax(){\n    var xhr = null;\n    var url = window.location.href;\n    if(window.xhrRequest){\n      xhr = new window.xhrRequest();\n    }else{ // ie\n      xhr = new ActiveObject(\"Microsoft\")\n    }\n    // 通过get的方式请求当前文件\n    xhr.open(\"get\",url,false);  //同步\n    //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。\n    //xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n    //xhr.send(\"fname=Henry&lname=Ford\");\n    xhr.send(null);\n    // 监听请求状态变化 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：\n    xhr.onreadystatechange = function(){\n        //if (xhr.readyState==4 && xhr.status==200)\n        if(xhr.readyState===2){\n            var time = xhr.getResponseHeader(\"Date\");\n            var curDate = new Date(time);\n        }\n    }\n    if (xhr.status === 200) {\n        var time = xhr.getResponseHeader(\"Date\");\n        curDate = new Date(time);\n    }\n\n    //其他ajax相关\n    //xhr.responseText\t获得字符串形式的响应数据。\n    //xhr.responseXML\t获得 XML 形式的响应数据。\n  }\n```\n2.jquery-ajax方法获取:\n```\n$.ajax({\n    type: 'HEAD', // 获取头信息，type=HEAD即可\n    url : window.location.href,\n    complete: function(xhr,data){// 获取相关Http Response header\n        var wpoInfo = {\n            \"date\" : xhr.getResponseHeader('Date'),// 服务器端时间\n            \"contentEncoding\" : xhr.getResponseHeader('Content-Encoding'),// 如果开启了gzip，会返回这个东西\n            \"connection\" : xhr.getResponseHeader('Connection'),// keep-alive ？ close？\n            \"contentLength\" : xhr.getResponseHeader('Content-Length'),// 响应长度\n            \"server\" : xhr.getResponseHeader('Server'),// 服务器类型，apache？lighttpd？\n            \"vary\" : xhr.getResponseHeader('Vary'),\n            \"transferEncoding\" : xhr.getResponseHeader('Transfer-Encoding'),\n            \"contentType\" : xhr.getResponseHeader('Content-Type'),// text/html ? text/xml?\n            \"cacheControl\" : xhr.getResponseHeader('Cache-Control'),\n            \"exprires\" : xhr.getResponseHeader('Exprires'),// 生命周期？\n            \"lastModified\" : xhr.getResponseHeader('Last-Modified')\n        };\n        var curDate = new Date(wpoInfo.date);\n    }\n});\n```\n!!!\n注意:通过header获取的时间是格林威治时间,北京时间与格林威治时间或UTC时间相差8个时区，北京、上海、重庆位于东8区，\n所以北京时间过了8小时,获取之后记得换算成北京时间!!!\n","source":"_posts/http-headers.md","raw":"title: 前端获取服务器时间及其他Headers信息\ntags:\n    - http\n    - header\n    - 服务器时间\n---\n前端页面访问服务器时,获取服务器返回的http请求回来的header信息,如下图:\n![](/assets/img/header.png)\n获取Response Header的方法:\n<!-- more -->\n1.js-ajax方法获取:\n```\nfunction ajax(){\n    var xhr = null;\n    var url = window.location.href;\n    if(window.xhrRequest){\n      xhr = new window.xhrRequest();\n    }else{ // ie\n      xhr = new ActiveObject(\"Microsoft\")\n    }\n    // 通过get的方式请求当前文件\n    xhr.open(\"get\",url,false);  //同步\n    //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。\n    //xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n    //xhr.send(\"fname=Henry&lname=Ford\");\n    xhr.send(null);\n    // 监听请求状态变化 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：\n    xhr.onreadystatechange = function(){\n        //if (xhr.readyState==4 && xhr.status==200)\n        if(xhr.readyState===2){\n            var time = xhr.getResponseHeader(\"Date\");\n            var curDate = new Date(time);\n        }\n    }\n    if (xhr.status === 200) {\n        var time = xhr.getResponseHeader(\"Date\");\n        curDate = new Date(time);\n    }\n\n    //其他ajax相关\n    //xhr.responseText\t获得字符串形式的响应数据。\n    //xhr.responseXML\t获得 XML 形式的响应数据。\n  }\n```\n2.jquery-ajax方法获取:\n```\n$.ajax({\n    type: 'HEAD', // 获取头信息，type=HEAD即可\n    url : window.location.href,\n    complete: function(xhr,data){// 获取相关Http Response header\n        var wpoInfo = {\n            \"date\" : xhr.getResponseHeader('Date'),// 服务器端时间\n            \"contentEncoding\" : xhr.getResponseHeader('Content-Encoding'),// 如果开启了gzip，会返回这个东西\n            \"connection\" : xhr.getResponseHeader('Connection'),// keep-alive ？ close？\n            \"contentLength\" : xhr.getResponseHeader('Content-Length'),// 响应长度\n            \"server\" : xhr.getResponseHeader('Server'),// 服务器类型，apache？lighttpd？\n            \"vary\" : xhr.getResponseHeader('Vary'),\n            \"transferEncoding\" : xhr.getResponseHeader('Transfer-Encoding'),\n            \"contentType\" : xhr.getResponseHeader('Content-Type'),// text/html ? text/xml?\n            \"cacheControl\" : xhr.getResponseHeader('Cache-Control'),\n            \"exprires\" : xhr.getResponseHeader('Exprires'),// 生命周期？\n            \"lastModified\" : xhr.getResponseHeader('Last-Modified')\n        };\n        var curDate = new Date(wpoInfo.date);\n    }\n});\n```\n!!!\n注意:通过header获取的时间是格林威治时间,北京时间与格林威治时间或UTC时间相差8个时区，北京、上海、重庆位于东8区，\n所以北京时间过了8小时,获取之后记得换算成北京时间!!!\n","slug":"http-headers","published":1,"date":"2017-11-29T07:16:42.296Z","updated":"2017-11-29T07:16:42.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjan9rqap000510to0lct40y5","content":"<p>前端页面访问服务器时,获取服务器返回的http请求回来的header信息,如下图:<br><img src=\"/assets/img/header.png\" alt=\"\"><br>获取Response Header的方法:<br><a id=\"more\"></a><br>1.js-ajax方法获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ajax()&#123;</span><br><span class=\"line\">    var xhr = null;</span><br><span class=\"line\">    var url = window.location.href;</span><br><span class=\"line\">    if(window.xhrRequest)&#123;</span><br><span class=\"line\">      xhr = new window.xhrRequest();</span><br><span class=\"line\">    &#125;else&#123; // ie</span><br><span class=\"line\">      xhr = new ActiveObject(&quot;Microsoft&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 通过get的方式请求当前文件</span><br><span class=\"line\">    xhr.open(&quot;get&quot;,url,false);  //同步</span><br><span class=\"line\">    //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。</span><br><span class=\"line\">    //xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">    //xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br><span class=\"line\">    xhr.send(null);</span><br><span class=\"line\">    // 监听请求状态变化 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：</span><br><span class=\"line\">    xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">        //if (xhr.readyState==4 &amp;&amp; xhr.status==200)</span><br><span class=\"line\">        if(xhr.readyState===2)&#123;</span><br><span class=\"line\">            var time = xhr.getResponseHeader(&quot;Date&quot;);</span><br><span class=\"line\">            var curDate = new Date(time);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (xhr.status === 200) &#123;</span><br><span class=\"line\">        var time = xhr.getResponseHeader(&quot;Date&quot;);</span><br><span class=\"line\">        curDate = new Date(time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //其他ajax相关</span><br><span class=\"line\">    //xhr.responseText\t获得字符串形式的响应数据。</span><br><span class=\"line\">    //xhr.responseXML\t获得 XML 形式的响应数据。</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.jquery-ajax方法获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &apos;HEAD&apos;, // 获取头信息，type=HEAD即可</span><br><span class=\"line\">    url : window.location.href,</span><br><span class=\"line\">    complete: function(xhr,data)&#123;// 获取相关Http Response header</span><br><span class=\"line\">        var wpoInfo = &#123;</span><br><span class=\"line\">            &quot;date&quot; : xhr.getResponseHeader(&apos;Date&apos;),// 服务器端时间</span><br><span class=\"line\">            &quot;contentEncoding&quot; : xhr.getResponseHeader(&apos;Content-Encoding&apos;),// 如果开启了gzip，会返回这个东西</span><br><span class=\"line\">            &quot;connection&quot; : xhr.getResponseHeader(&apos;Connection&apos;),// keep-alive ？ close？</span><br><span class=\"line\">            &quot;contentLength&quot; : xhr.getResponseHeader(&apos;Content-Length&apos;),// 响应长度</span><br><span class=\"line\">            &quot;server&quot; : xhr.getResponseHeader(&apos;Server&apos;),// 服务器类型，apache？lighttpd？</span><br><span class=\"line\">            &quot;vary&quot; : xhr.getResponseHeader(&apos;Vary&apos;),</span><br><span class=\"line\">            &quot;transferEncoding&quot; : xhr.getResponseHeader(&apos;Transfer-Encoding&apos;),</span><br><span class=\"line\">            &quot;contentType&quot; : xhr.getResponseHeader(&apos;Content-Type&apos;),// text/html ? text/xml?</span><br><span class=\"line\">            &quot;cacheControl&quot; : xhr.getResponseHeader(&apos;Cache-Control&apos;),</span><br><span class=\"line\">            &quot;exprires&quot; : xhr.getResponseHeader(&apos;Exprires&apos;),// 生命周期？</span><br><span class=\"line\">            &quot;lastModified&quot; : xhr.getResponseHeader(&apos;Last-Modified&apos;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var curDate = new Date(wpoInfo.date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>!!!<br>注意:通过header获取的时间是格林威治时间,北京时间与格林威治时间或UTC时间相差8个时区，北京、上海、重庆位于东8区，<br>所以北京时间过了8小时,获取之后记得换算成北京时间!!!</p>\n","site":{"data":{}},"excerpt":"<p>前端页面访问服务器时,获取服务器返回的http请求回来的header信息,如下图:<br><img src=\"/assets/img/header.png\" alt=\"\"><br>获取Response Header的方法:<br>","more":"<br>1.js-ajax方法获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ajax()&#123;</span><br><span class=\"line\">    var xhr = null;</span><br><span class=\"line\">    var url = window.location.href;</span><br><span class=\"line\">    if(window.xhrRequest)&#123;</span><br><span class=\"line\">      xhr = new window.xhrRequest();</span><br><span class=\"line\">    &#125;else&#123; // ie</span><br><span class=\"line\">      xhr = new ActiveObject(&quot;Microsoft&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 通过get的方式请求当前文件</span><br><span class=\"line\">    xhr.open(&quot;get&quot;,url,false);  //同步</span><br><span class=\"line\">    //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。</span><br><span class=\"line\">    //xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">    //xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br><span class=\"line\">    xhr.send(null);</span><br><span class=\"line\">    // 监听请求状态变化 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：</span><br><span class=\"line\">    xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">        //if (xhr.readyState==4 &amp;&amp; xhr.status==200)</span><br><span class=\"line\">        if(xhr.readyState===2)&#123;</span><br><span class=\"line\">            var time = xhr.getResponseHeader(&quot;Date&quot;);</span><br><span class=\"line\">            var curDate = new Date(time);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (xhr.status === 200) &#123;</span><br><span class=\"line\">        var time = xhr.getResponseHeader(&quot;Date&quot;);</span><br><span class=\"line\">        curDate = new Date(time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //其他ajax相关</span><br><span class=\"line\">    //xhr.responseText\t获得字符串形式的响应数据。</span><br><span class=\"line\">    //xhr.responseXML\t获得 XML 形式的响应数据。</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.jquery-ajax方法获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &apos;HEAD&apos;, // 获取头信息，type=HEAD即可</span><br><span class=\"line\">    url : window.location.href,</span><br><span class=\"line\">    complete: function(xhr,data)&#123;// 获取相关Http Response header</span><br><span class=\"line\">        var wpoInfo = &#123;</span><br><span class=\"line\">            &quot;date&quot; : xhr.getResponseHeader(&apos;Date&apos;),// 服务器端时间</span><br><span class=\"line\">            &quot;contentEncoding&quot; : xhr.getResponseHeader(&apos;Content-Encoding&apos;),// 如果开启了gzip，会返回这个东西</span><br><span class=\"line\">            &quot;connection&quot; : xhr.getResponseHeader(&apos;Connection&apos;),// keep-alive ？ close？</span><br><span class=\"line\">            &quot;contentLength&quot; : xhr.getResponseHeader(&apos;Content-Length&apos;),// 响应长度</span><br><span class=\"line\">            &quot;server&quot; : xhr.getResponseHeader(&apos;Server&apos;),// 服务器类型，apache？lighttpd？</span><br><span class=\"line\">            &quot;vary&quot; : xhr.getResponseHeader(&apos;Vary&apos;),</span><br><span class=\"line\">            &quot;transferEncoding&quot; : xhr.getResponseHeader(&apos;Transfer-Encoding&apos;),</span><br><span class=\"line\">            &quot;contentType&quot; : xhr.getResponseHeader(&apos;Content-Type&apos;),// text/html ? text/xml?</span><br><span class=\"line\">            &quot;cacheControl&quot; : xhr.getResponseHeader(&apos;Cache-Control&apos;),</span><br><span class=\"line\">            &quot;exprires&quot; : xhr.getResponseHeader(&apos;Exprires&apos;),// 生命周期？</span><br><span class=\"line\">            &quot;lastModified&quot; : xhr.getResponseHeader(&apos;Last-Modified&apos;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var curDate = new Date(wpoInfo.date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>!!!<br>注意:通过header获取的时间是格林威治时间,北京时间与格林威治时间或UTC时间相差8个时区，北京、上海、重庆位于东8区，<br>所以北京时间过了8小时,获取之后记得换算成北京时间!!!</p>"},{"title":"http请求返回状态码解析","_content":"### 一些常见的状态码为：\n  - 200：服务器响应正常。\n  - 304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。\n  - 400：无法找到请求的资源。\n  - 401：访问资源的权限不够。\n  - 403：没有权限访问资源。\n  - 404：需要访问的资源不存在。\n  - 405：需要访问的资源被禁止。\n  - 407：访问的资源需要代理身份验证。\n  - 414：请求的URL太长。\n  - 500：服务器内部错误。\n\n### 下面提供 HTTP 状态码的完整列表：\n\n<!-- more -->\n\n#### 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\n100（继续）\t请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\n101（切换协议）\t请求者已要求服务器切换协议，服务器已确认并准备切换。\n\n#### 2xx （成功）表示成功处理了请求的状态码。\n200（成功）\t服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。\n201（已创建）\t请求成功并且服务器创建了新的资源。\n202（已接受）\t服务器已接受请求，但尚未处理。\n203（非授权信息）\t服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204（无内容）\t服务器成功处理了请求，但没有返回任何内容。\n205（重置内容）\t服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。\n206（部分内容）\t服务器成功处理了部分 GET 请求。\n\n#### 3xx （重定向）要完成请求，需要进一步操作。\n##### 通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。\n300（多种选择）\t针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。\n301（永久移动）\t请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。\n302（临时移动）\t服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。\n303（查看其他位置）\t请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。\n304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。\n305（使用代理）\t请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。\n307（临时重定向）\t服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=answer.py?answer=>301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。\n\n#### 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\n400（错误请求）\t服务器不理解请求的语法。\n401（未授权）\t请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。\n403（禁止）\t服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。\n404（未找到） 服务器找不到请求的网页。\n405（方法禁用）\t禁用请求中指定的方法。\n406（不接受）\t无法使用请求的内容特性响应请求的网页。\n407（需要代理授权）\t此状态码与 <a href=answer.py?answer=35128>401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。\n408（请求超时）\t服务器等候请求时发生超时。\n409（冲突）\t服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。\n410（已删除）\t如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。\n411（需要有效长度）\t服务器不接受不含有效内容长度标头字段的请求。\n412（未满足前提条件）\t服务器未满足请求者在请求中设置的其中一个前提条件。\n413（请求实体过大）\t服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\n414（请求的 URI 过长）\t请求的 URI（通常为网址）过长，服务器无法处理。\n415（不支持的媒体类型）\t请求的格式不受请求页面的支持。\n416（请求范围不符合要求）\t如果页面无法提供请求的范围，则服务器会返回此状态码。\n417（未满足期望值）\t服务器未满足\"期望\"请求标头字段的要求。\n\n#### 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\n500（服务器内部错误）\t服务器遇到错误，无法完成请求。\n501（尚未实施）\t服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。\n502（错误网关）\t服务器作为网关或代理，从上游服务器收到无效响应。\n503（服务不可用）\t服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。\n504（网关超时）\t服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n505（HTTP 版本不受支持）\t服务器不支持请求中所用的 HTTP 协议版本。\n\n转自http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html","source":"_posts/http-status.md","raw":"title: http请求返回状态码解析\ntags:\n - http\n - 状态码\n---\n### 一些常见的状态码为：\n  - 200：服务器响应正常。\n  - 304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。\n  - 400：无法找到请求的资源。\n  - 401：访问资源的权限不够。\n  - 403：没有权限访问资源。\n  - 404：需要访问的资源不存在。\n  - 405：需要访问的资源被禁止。\n  - 407：访问的资源需要代理身份验证。\n  - 414：请求的URL太长。\n  - 500：服务器内部错误。\n\n### 下面提供 HTTP 状态码的完整列表：\n\n<!-- more -->\n\n#### 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\n100（继续）\t请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\n101（切换协议）\t请求者已要求服务器切换协议，服务器已确认并准备切换。\n\n#### 2xx （成功）表示成功处理了请求的状态码。\n200（成功）\t服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。\n201（已创建）\t请求成功并且服务器创建了新的资源。\n202（已接受）\t服务器已接受请求，但尚未处理。\n203（非授权信息）\t服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204（无内容）\t服务器成功处理了请求，但没有返回任何内容。\n205（重置内容）\t服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。\n206（部分内容）\t服务器成功处理了部分 GET 请求。\n\n#### 3xx （重定向）要完成请求，需要进一步操作。\n##### 通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。\n300（多种选择）\t针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。\n301（永久移动）\t请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。\n302（临时移动）\t服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。\n303（查看其他位置）\t请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。\n304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。\n305（使用代理）\t请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。\n307（临时重定向）\t服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=answer.py?answer=>301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。\n\n#### 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\n400（错误请求）\t服务器不理解请求的语法。\n401（未授权）\t请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。\n403（禁止）\t服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。\n404（未找到） 服务器找不到请求的网页。\n405（方法禁用）\t禁用请求中指定的方法。\n406（不接受）\t无法使用请求的内容特性响应请求的网页。\n407（需要代理授权）\t此状态码与 <a href=answer.py?answer=35128>401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。\n408（请求超时）\t服务器等候请求时发生超时。\n409（冲突）\t服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。\n410（已删除）\t如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。\n411（需要有效长度）\t服务器不接受不含有效内容长度标头字段的请求。\n412（未满足前提条件）\t服务器未满足请求者在请求中设置的其中一个前提条件。\n413（请求实体过大）\t服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\n414（请求的 URI 过长）\t请求的 URI（通常为网址）过长，服务器无法处理。\n415（不支持的媒体类型）\t请求的格式不受请求页面的支持。\n416（请求范围不符合要求）\t如果页面无法提供请求的范围，则服务器会返回此状态码。\n417（未满足期望值）\t服务器未满足\"期望\"请求标头字段的要求。\n\n#### 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\n500（服务器内部错误）\t服务器遇到错误，无法完成请求。\n501（尚未实施）\t服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。\n502（错误网关）\t服务器作为网关或代理，从上游服务器收到无效响应。\n503（服务不可用）\t服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。\n504（网关超时）\t服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n505（HTTP 版本不受支持）\t服务器不支持请求中所用的 HTTP 协议版本。\n\n转自http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html","slug":"http-status","published":1,"date":"2017-11-29T07:15:08.773Z","updated":"2017-11-29T07:15:08.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjan9rqar000610to8qbm61ky","content":"<h3 id=\"一些常见的状态码为：\"><a href=\"#一些常见的状态码为：\" class=\"headerlink\" title=\"一些常见的状态码为：\"></a>一些常见的状态码为：</h3><ul>\n<li>200：服务器响应正常。</li>\n<li>304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。</li>\n<li>400：无法找到请求的资源。</li>\n<li>401：访问资源的权限不够。</li>\n<li>403：没有权限访问资源。</li>\n<li>404：需要访问的资源不存在。</li>\n<li>405：需要访问的资源被禁止。</li>\n<li>407：访问的资源需要代理身份验证。</li>\n<li>414：请求的URL太长。</li>\n<li>500：服务器内部错误。</li>\n</ul>\n<h3 id=\"下面提供-HTTP-状态码的完整列表：\"><a href=\"#下面提供-HTTP-状态码的完整列表：\" class=\"headerlink\" title=\"下面提供 HTTP 状态码的完整列表：\"></a>下面提供 HTTP 状态码的完整列表：</h3><a id=\"more\"></a>\n<h4 id=\"1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\"><a href=\"#1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\" class=\"headerlink\" title=\"1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\"></a>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。</h4><p>100（继续）    请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101（切换协议）    请求者已要求服务器切换协议，服务器已确认并准备切换。</p>\n<h4 id=\"2xx-（成功）表示成功处理了请求的状态码。\"><a href=\"#2xx-（成功）表示成功处理了请求的状态码。\" class=\"headerlink\" title=\"2xx （成功）表示成功处理了请求的状态码。\"></a>2xx （成功）表示成功处理了请求的状态码。</h4><p>200（成功）    服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。<br>201（已创建）    请求成功并且服务器创建了新的资源。<br>202（已接受）    服务器已接受请求，但尚未处理。<br>203（非授权信息）    服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204（无内容）    服务器成功处理了请求，但没有返回任何内容。<br>205（重置内容）    服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。<br>206（部分内容）    服务器成功处理了部分 GET 请求。</p>\n<h4 id=\"3xx-（重定向）要完成请求，需要进一步操作。\"><a href=\"#3xx-（重定向）要完成请求，需要进一步操作。\" class=\"headerlink\" title=\"3xx （重定向）要完成请求，需要进一步操作。\"></a>3xx （重定向）要完成请求，需要进一步操作。</h4><h5 id=\"通常，这些状态码用来重定向。Google-建议您在每次请求中使用重定向不要超过-5-次。您可以使用网站管理员工具查看一下-Googlebot-在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致-Googlebot-无法抓取的网址。\"><a href=\"#通常，这些状态码用来重定向。Google-建议您在每次请求中使用重定向不要超过-5-次。您可以使用网站管理员工具查看一下-Googlebot-在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致-Googlebot-无法抓取的网址。\" class=\"headerlink\" title=\"通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。\"></a>通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。</h5><p>300（多种选择）    针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301（永久移动）    请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。<br>302（临时移动）    服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。<br>303（查看其他位置）    请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。<br>304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。<br>305（使用代理）    请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。<br>307（临时重定向）    服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=\"answer.py?answer=\">301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>\n<h4 id=\"4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\"><a href=\"#4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\" class=\"headerlink\" title=\"4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\"></a>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。</h4><p>400（错误请求）    服务器不理解请求的语法。<br>401（未授权）    请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。<br>403（禁止）    服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。<br>404（未找到） 服务器找不到请求的网页。<br>405（方法禁用）    禁用请求中指定的方法。<br>406（不接受）    无法使用请求的内容特性响应请求的网页。<br>407（需要代理授权）    此状态码与 <a href=\"answer.py?answer=35128\">401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。<br>408（请求超时）    服务器等候请求时发生超时。<br>409（冲突）    服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。<br>410（已删除）    如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。<br>411（需要有效长度）    服务器不接受不含有效内容长度标头字段的请求。<br>412（未满足前提条件）    服务器未满足请求者在请求中设置的其中一个前提条件。<br>413（请求实体过大）    服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414（请求的 URI 过长）    请求的 URI（通常为网址）过长，服务器无法处理。<br>415（不支持的媒体类型）    请求的格式不受请求页面的支持。<br>416（请求范围不符合要求）    如果页面无法提供请求的范围，则服务器会返回此状态码。<br>417（未满足期望值）    服务器未满足”期望”请求标头字段的要求。</p>\n<h4 id=\"5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\"><a href=\"#5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\" class=\"headerlink\" title=\"5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\"></a>5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</h4><p>500（服务器内部错误）    服务器遇到错误，无法完成请求。<br>501（尚未实施）    服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br>502（错误网关）    服务器作为网关或代理，从上游服务器收到无效响应。<br>503（服务不可用）    服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br>504（网关超时）    服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505（HTTP 版本不受支持）    服务器不支持请求中所用的 HTTP 协议版本。</p>\n<p>转自<a href=\"http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html\" target=\"_blank\" rel=\"noopener\">http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一些常见的状态码为：\"><a href=\"#一些常见的状态码为：\" class=\"headerlink\" title=\"一些常见的状态码为：\"></a>一些常见的状态码为：</h3><ul>\n<li>200：服务器响应正常。</li>\n<li>304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。</li>\n<li>400：无法找到请求的资源。</li>\n<li>401：访问资源的权限不够。</li>\n<li>403：没有权限访问资源。</li>\n<li>404：需要访问的资源不存在。</li>\n<li>405：需要访问的资源被禁止。</li>\n<li>407：访问的资源需要代理身份验证。</li>\n<li>414：请求的URL太长。</li>\n<li>500：服务器内部错误。</li>\n</ul>\n<h3 id=\"下面提供-HTTP-状态码的完整列表：\"><a href=\"#下面提供-HTTP-状态码的完整列表：\" class=\"headerlink\" title=\"下面提供 HTTP 状态码的完整列表：\"></a>下面提供 HTTP 状态码的完整列表：</h3>","more":"<h4 id=\"1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\"><a href=\"#1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\" class=\"headerlink\" title=\"1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\"></a>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。</h4><p>100（继续）    请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101（切换协议）    请求者已要求服务器切换协议，服务器已确认并准备切换。</p>\n<h4 id=\"2xx-（成功）表示成功处理了请求的状态码。\"><a href=\"#2xx-（成功）表示成功处理了请求的状态码。\" class=\"headerlink\" title=\"2xx （成功）表示成功处理了请求的状态码。\"></a>2xx （成功）表示成功处理了请求的状态码。</h4><p>200（成功）    服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。<br>201（已创建）    请求成功并且服务器创建了新的资源。<br>202（已接受）    服务器已接受请求，但尚未处理。<br>203（非授权信息）    服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204（无内容）    服务器成功处理了请求，但没有返回任何内容。<br>205（重置内容）    服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。<br>206（部分内容）    服务器成功处理了部分 GET 请求。</p>\n<h4 id=\"3xx-（重定向）要完成请求，需要进一步操作。\"><a href=\"#3xx-（重定向）要完成请求，需要进一步操作。\" class=\"headerlink\" title=\"3xx （重定向）要完成请求，需要进一步操作。\"></a>3xx （重定向）要完成请求，需要进一步操作。</h4><h5 id=\"通常，这些状态码用来重定向。Google-建议您在每次请求中使用重定向不要超过-5-次。您可以使用网站管理员工具查看一下-Googlebot-在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致-Googlebot-无法抓取的网址。\"><a href=\"#通常，这些状态码用来重定向。Google-建议您在每次请求中使用重定向不要超过-5-次。您可以使用网站管理员工具查看一下-Googlebot-在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致-Googlebot-无法抓取的网址。\" class=\"headerlink\" title=\"通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。\"></a>通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。</h5><p>300（多种选择）    针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301（永久移动）    请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。<br>302（临时移动）    服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。<br>303（查看其他位置）    请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。<br>304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。<br>305（使用代理）    请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。<br>307（临时重定向）    服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=\"answer.py?answer=\">301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>\n<h4 id=\"4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\"><a href=\"#4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\" class=\"headerlink\" title=\"4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\"></a>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。</h4><p>400（错误请求）    服务器不理解请求的语法。<br>401（未授权）    请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。<br>403（禁止）    服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。<br>404（未找到） 服务器找不到请求的网页。<br>405（方法禁用）    禁用请求中指定的方法。<br>406（不接受）    无法使用请求的内容特性响应请求的网页。<br>407（需要代理授权）    此状态码与 <a href=\"answer.py?answer=35128\">401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。<br>408（请求超时）    服务器等候请求时发生超时。<br>409（冲突）    服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。<br>410（已删除）    如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。<br>411（需要有效长度）    服务器不接受不含有效内容长度标头字段的请求。<br>412（未满足前提条件）    服务器未满足请求者在请求中设置的其中一个前提条件。<br>413（请求实体过大）    服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414（请求的 URI 过长）    请求的 URI（通常为网址）过长，服务器无法处理。<br>415（不支持的媒体类型）    请求的格式不受请求页面的支持。<br>416（请求范围不符合要求）    如果页面无法提供请求的范围，则服务器会返回此状态码。<br>417（未满足期望值）    服务器未满足”期望”请求标头字段的要求。</p>\n<h4 id=\"5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\"><a href=\"#5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\" class=\"headerlink\" title=\"5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\"></a>5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</h4><p>500（服务器内部错误）    服务器遇到错误，无法完成请求。<br>501（尚未实施）    服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br>502（错误网关）    服务器作为网关或代理，从上游服务器收到无效响应。<br>503（服务不可用）    服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br>504（网关超时）    服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505（HTTP 版本不受支持）    服务器不支持请求中所用的 HTTP 协议版本。</p>\n<p>转自<a href=\"http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html\" target=\"_blank\" rel=\"noopener\">http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html</a></p>"},{"title":"HTTP协议 - HyperText Transfer Protocol，超文本传输协议","_content":">因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### 工作原理\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\nWeb服务器有：Apache服务器，IIS服务器（Internet Information Services）等。\nWeb服务器根据接收到的请求后，向客户端发送响应信息。\nHTTP默认端口号为80，但是你也可以改为8080或者其他端口。\n#### HTTP - 三点注意事项：\n- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)\n- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n  HTTP协议通信流程：\n![](/assets/img/http-lc.png)\n(Common Gateway Interface，简称CGI)\n\n<!-- more -->\n### 请求方法\n根据HTTP标准，HTTP请求可以使用多种请求方法。\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n1.GET\t请求指定的页面信息，并返回实体主体。\n2.HEAD\t类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3.POST\t向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4.PUT\t从客户端向服务器传送的数据取代指定的文档的内容。\n5.DELETE\t请求服务器删除指定的页面。\n6.CONNECT\tHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7.OPTIONS\t允许客户端查看服务器的性能。\n8.TRACE\t回显服务器收到的请求，主要用于测试或诊断。\n\n### 响应头信息\n- Allow 服务器支持哪些请求方法（如GET、POST等）。\n- Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\n- Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\n- Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\n- Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\n- Expires 应该在什么时候认为文档已经过期，从而不再缓存它？\n- Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\n- Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\n- Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=<span>http://host/path</span>\")让浏览器读取指定的页面。\n  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"</pre>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。\n  注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。\n  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\n- Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\n- Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\n- WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。\n  注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n","source":"_posts/http.md","raw":"title: HTTP协议 - HyperText Transfer Protocol，超文本传输协议\ntags:\n    - http\n---\n>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### 工作原理\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\nWeb服务器有：Apache服务器，IIS服务器（Internet Information Services）等。\nWeb服务器根据接收到的请求后，向客户端发送响应信息。\nHTTP默认端口号为80，但是你也可以改为8080或者其他端口。\n#### HTTP - 三点注意事项：\n- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)\n- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n  HTTP协议通信流程：\n![](/assets/img/http-lc.png)\n(Common Gateway Interface，简称CGI)\n\n<!-- more -->\n### 请求方法\n根据HTTP标准，HTTP请求可以使用多种请求方法。\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n1.GET\t请求指定的页面信息，并返回实体主体。\n2.HEAD\t类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3.POST\t向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4.PUT\t从客户端向服务器传送的数据取代指定的文档的内容。\n5.DELETE\t请求服务器删除指定的页面。\n6.CONNECT\tHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7.OPTIONS\t允许客户端查看服务器的性能。\n8.TRACE\t回显服务器收到的请求，主要用于测试或诊断。\n\n### 响应头信息\n- Allow 服务器支持哪些请求方法（如GET、POST等）。\n- Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\n- Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\n- Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\n- Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\n- Expires 应该在什么时候认为文档已经过期，从而不再缓存它？\n- Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\n- Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\n- Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=<span>http://host/path</span>\")让浏览器读取指定的页面。\n  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"</pre>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。\n  注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。\n  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\n- Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\n- Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\n- WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。\n  注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n","slug":"http","published":1,"date":"2017-11-29T09:21:57.802Z","updated":"2017-11-29T09:21:57.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjan9rqbd000s10toze5k0wpf","content":"<blockquote>\n<p>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n</blockquote>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>\n<h4 id=\"HTTP-三点注意事项：\"><a href=\"#HTTP-三点注意事项：\" class=\"headerlink\" title=\"HTTP - 三点注意事项：\"></a>HTTP - 三点注意事项：</h4><ul>\n<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>\n<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)</li>\n<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>HTTP协议通信流程：<br><img src=\"/assets/img/http-lc.png\" alt=\"\"><br>(Common Gateway Interface，简称CGI)</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>1.GET    请求指定的页面信息，并返回实体主体。<br>2.HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3.POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>4.PUT    从客户端向服务器传送的数据取代指定的文档的内容。<br>5.DELETE    请求服务器删除指定的页面。<br>6.CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>7.OPTIONS    允许客户端查看服务器的性能。<br>8.TRACE    回显服务器收到的请求，主要用于测试或诊断。</p>\n<h3 id=\"响应头信息\"><a href=\"#响应头信息\" class=\"headerlink\" title=\"响应头信息\"></a>响应头信息</h3><ul>\n<li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li>\n<li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li>\n<li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>\n<li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</li>\n<li>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>\n<li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li>\n<li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li>\n<li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li>\n<li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<span><a href=\"http://host/path\" target=\"_blank\" rel=\"noopener\">http://host/path</a></span>“)让浏览器读取指定的页面。<br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path\" target=\"_blank\" rel=\"noopener\">http://host/path</a>“＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。<br>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。<br>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li>\n<li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li>\n<li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</li>\n<li>WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n</blockquote>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>\n<h4 id=\"HTTP-三点注意事项：\"><a href=\"#HTTP-三点注意事项：\" class=\"headerlink\" title=\"HTTP - 三点注意事项：\"></a>HTTP - 三点注意事项：</h4><ul>\n<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>\n<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)</li>\n<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>HTTP协议通信流程：<br><img src=\"/assets/img/http-lc.png\" alt=\"\"><br>(Common Gateway Interface，简称CGI)</li>\n</ul>","more":"<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>1.GET    请求指定的页面信息，并返回实体主体。<br>2.HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3.POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>4.PUT    从客户端向服务器传送的数据取代指定的文档的内容。<br>5.DELETE    请求服务器删除指定的页面。<br>6.CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>7.OPTIONS    允许客户端查看服务器的性能。<br>8.TRACE    回显服务器收到的请求，主要用于测试或诊断。</p>\n<h3 id=\"响应头信息\"><a href=\"#响应头信息\" class=\"headerlink\" title=\"响应头信息\"></a>响应头信息</h3><ul>\n<li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li>\n<li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li>\n<li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>\n<li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</li>\n<li>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>\n<li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li>\n<li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li>\n<li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li>\n<li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<span><a href=\"http://host/path\" target=\"_blank\" rel=\"noopener\">http://host/path</a></span>“)让浏览器读取指定的页面。<br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path\" target=\"_blank\" rel=\"noopener\">http://host/path</a>“＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。<br>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。<br>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li>\n<li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li>\n<li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</li>\n<li>WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</li>\n</ul>"},{"title":"响应式布局和移动端适配方案","_content":"前端响应式开发包括两个方向,web(pc)端的页面显示和移动端的页面显示,一般页面内容比较少,布局相对简单的页面可以直接采用媒体查询的方式来实现响应式;\n移动端和PC端需要展示不同的页面样式风格的页面,可以采用pc端响应式,移动端自动适配的方案.\n1.响应式布局 2.移动端适配-rem\n\n>不同的需求,采用不同的方案\n\n### 一.响应式布局\n1.设计思路：\n使用CSS3中媒体查询的大致思路就是判断网页在不同设备中所处的宽度范围，这样的范围可能有三种（PC、平板、手机），也可能有四种（PC、平板、中大屏手机、小屏手机），当然也可能只需要两种（平板、手机，PC端单独开发一版时可不作为CSS3媒体查询的使用对象），并为各种宽度范围情况下的所需页面元素套用不同的CSS样式，从而适配各种设备。\n\n<!-- more -->\n\n2.响应式网页开发中的宽度问题：\n在实际开发中，通常需要设置响应式网页宽度的最大值，一旦忽略最大宽度，臃肿或零散的网页布局都会造成视觉洪灾，也就是我们常说的看起来很low。\n目前最为常见的宽度基本上都是：大于或等于960px的PC端（1920px、1600px、1440px、1280px、1140px、960px）、960px至640px之间的平板端（768px、640px）以及640px以下的手机端（480px、320px），以上宽度存在已久，且显示设备中的网页宽度会长期处于这样的状态下，在响应式网页宽度设计上，基本从这几个尺寸考虑就已经足够。\n\n3.初始化设置：\n在HTML文件中，网页顶部<head></head>标签中插入一句话：\n```\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n这句话在于对响应式网页做一个初始化设置，主要包括：\nname=\"viewport\"：标记显示设备为视口；\nwidth = device-width：宽度等于当前设备的宽度；\ninitial-scale：初始的缩放比例（默认设置为1.0）；\nminimum-scale：允许用户缩放到的最小比例（默认设置为1.0）；\nmaximum-scale：允许用户缩放到的最大比例（默认设置为1.0）；\nuser-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）。\n\n4.解决IE浏览器的兼容性问题：\n因为IE浏览器(IE8)不支持HTML5和CSS3中的media，所以要加载用于解决IE浏览器兼容性问题的JS文件：\n```\n    <!--[if lt IE 9]>\n    <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n    <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n    <![endif]-->\n```\n两个<script></script>标签中的src属性所指向的文件链接地址为固定地址中的文件，直接异地引用就好，不用下载到本地引用。\n\n5.设置IE的渲染方式为最高：\n现在有很多人的IE浏览器都升级到IE9以上，这个时候会有很多诡异的事情发生，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8，为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新：\n```\n<meta http-equiv=\"X-UA-Compatible\"content=\"IE=edge\">\n```\n当然还有一个更给力的写法：\n```\n<meta http-equiv=\"X-UA-Compatible\"content=\"IE=Edge，chrome=1\">\n```\n这段代码后面加了一个chrome=1，这是由于Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果用户电脑安装这个chrome插件，就可让电脑内的IE浏览器规避版本因素，使用Webkit引擎及V8引擎进行排版及运算。当然如果用户没装这个插件，这段代码就会让IE浏览器以最高的文档模式展现效果。\n\n6.CSS3 media 媒体查询的写法：\n```\n@media screen and (max-width: 960px){body{background:#000;}}\n```\n这是一个media的标准写法，在CSS文件中，意为：当页面小于960px时执行以下CSS代码，具体内容暂不用管。\n对于上述代码中的screen，意为在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。目前很多网站都会直接省略screen,从而不需要考虑用户打印网页的需求，所以又有这种写法：\n```\n@media (max-width: 960px){\n    body{background:#000;}\n}\n```\n本着思维严谨的原则，一般不采用这种写法。\n\n7.CSS3媒体查询主体代码组合：\n在响应式网页布局中需要持续运用媒体查询代码组合，主要作用在于判断所适配屏幕的宽度，并根据各种宽度条件套用不同的CSS样式。\n- 如当屏幕宽度等于960px时，将网页背景色变为红色：\n```\n@media screen and (max-device-width:960px){\n    body{background:red;}\n}\n```\n\n- 如当屏幕宽度最大为960px（小于960px）时，将网页背景色变为黑色：\n```\n@media screen and (max-width: 960px){\n    body{background:#000;}\n}\n```\n\n- 如当屏幕宽度最小为960px（大于960px）时，将网页背景色变为桔色：\n```\n@media screen and (min-width:960px){\n    body{background:orange;}\n}\n```\n\n- 更为常见的是混合使用，如当屏幕宽度介于960px和1200px之间时，将网页背景色变为黄色：\n```\n@media screen and (min-width:960px) and(max-width:1200px){\n    body{background:yellow;}\n}\n```\n\n8.media媒体查询所有参数汇总：\n媒体查询器中还包含并不常用的相关功能，悉如示下：\nwidth:浏览器可视宽度，\nheight:浏览器可视高度，\ndevice-width:设备屏幕的宽度，\ndevice-height:设备屏幕的高度，\norientation:检测设备目前处于横向还是纵向状态，\naspect-ratio:检测浏览器可视宽度和高度的比例(例如：aspect-ratio:16/9)，\ndevice-aspect-ratio:检测设备的宽度和高度的比例，\ncolor:检测颜色的位数（例如：min-color:32就会检测设备是否拥有32位颜色），\ncolor-index:检查设备颜色索引表中的颜色（他的值不能是负数），\nmonochrome:检测单色楨缓冲区域中的每个像素的位数（这个太高级，估计咱很少会用的到），\nresolution:检测屏幕或打印机的分辨率(例如：min-resolution:300dpi或min-resolution:118dpcm)，\ngrid：检测输出的设备是网格的还是位图设备。\n\n9.扩展——在CSS2中同样有媒体查询：\nmedia媒体查询并不是CSS3诞生之后的专用功能，早在CSS2开始就已经支持media，比如：\n在HTML文件中的<head></head>标签中写入这句：\n```\n<link rel=\"stylesheet\"type=\"text/css\" media=\"screen\"href=\"style.css\">\n```\n以上是CSS2实现的衬线用法，href属性中写入在某单一显示设备中链接的CSS文件，但仅供入门，\n如要判断移动设备是否为纵向放置的显示屏，可以这样写：\n```\n<link rel=\"stylesheet\" type=\"text/css\"media=\"screen and (orientation:portrait)\"href=\"style.css\">\n```\n如要让小于960px的页面执行指定的CSS样式文件，可以这样写：\n```\n<link rel=\"stylesheet\"type=\"text/css\" media=\"screen and (max-width:960px)\"href=\"style.css\">\n```\nCSS2中的媒体查询方法放到现在并不推荐使用，最大的弊端在于这样会增加页面http的请求次数，增加页面负担，使用CSS3中的媒体查询才是目前的最佳方法。\n\n---\n### 二.移动端rem适配\n---\n1.设计思路:\nrem是css3相对根节点(html)的字体大小的单位,通过设备宽度算出每个rem所对应的px,来实现动态适配.\n\n2.动态设置html的font-size,根据参照的设备宽度设置1rem = ?px;\n屏幕的总宽度即为(均分份数)16rem.\n```\nvar html = document.documentElement;\nvar width = html.getBoundingClientRect().width;     //设备尺寸绝对宽度(width = window.screen.width)\nhtml.style.fontSize = width / 16 + 'px';            //将屏幕分成16份：iphone5下（320/16） 1rem = 20px;\n//html.style.fontSize = width / 15 + 'px';          //将屏幕分成15份：iphone6下（375/15） 1rem = 25px;\n//html.style.fontSize = width / 18 + 'px';          //将屏幕分成15份：iphone6s调试\n```\n\n3.编写样式时,所有的尺寸单位均使用rem即可,实际开发中可使用编辑器的转换插件将px转成对应的rem值.\n\n---\n[【查看源码】](https://github.com/HoldCast/resposive)","source":"_posts/responseLayout.md","raw":"title: 响应式布局和移动端适配方案\ntags:\n  - 响应式\n  - 移动适配\n  - rem\n---\n前端响应式开发包括两个方向,web(pc)端的页面显示和移动端的页面显示,一般页面内容比较少,布局相对简单的页面可以直接采用媒体查询的方式来实现响应式;\n移动端和PC端需要展示不同的页面样式风格的页面,可以采用pc端响应式,移动端自动适配的方案.\n1.响应式布局 2.移动端适配-rem\n\n>不同的需求,采用不同的方案\n\n### 一.响应式布局\n1.设计思路：\n使用CSS3中媒体查询的大致思路就是判断网页在不同设备中所处的宽度范围，这样的范围可能有三种（PC、平板、手机），也可能有四种（PC、平板、中大屏手机、小屏手机），当然也可能只需要两种（平板、手机，PC端单独开发一版时可不作为CSS3媒体查询的使用对象），并为各种宽度范围情况下的所需页面元素套用不同的CSS样式，从而适配各种设备。\n\n<!-- more -->\n\n2.响应式网页开发中的宽度问题：\n在实际开发中，通常需要设置响应式网页宽度的最大值，一旦忽略最大宽度，臃肿或零散的网页布局都会造成视觉洪灾，也就是我们常说的看起来很low。\n目前最为常见的宽度基本上都是：大于或等于960px的PC端（1920px、1600px、1440px、1280px、1140px、960px）、960px至640px之间的平板端（768px、640px）以及640px以下的手机端（480px、320px），以上宽度存在已久，且显示设备中的网页宽度会长期处于这样的状态下，在响应式网页宽度设计上，基本从这几个尺寸考虑就已经足够。\n\n3.初始化设置：\n在HTML文件中，网页顶部<head></head>标签中插入一句话：\n```\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n这句话在于对响应式网页做一个初始化设置，主要包括：\nname=\"viewport\"：标记显示设备为视口；\nwidth = device-width：宽度等于当前设备的宽度；\ninitial-scale：初始的缩放比例（默认设置为1.0）；\nminimum-scale：允许用户缩放到的最小比例（默认设置为1.0）；\nmaximum-scale：允许用户缩放到的最大比例（默认设置为1.0）；\nuser-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）。\n\n4.解决IE浏览器的兼容性问题：\n因为IE浏览器(IE8)不支持HTML5和CSS3中的media，所以要加载用于解决IE浏览器兼容性问题的JS文件：\n```\n    <!--[if lt IE 9]>\n    <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n    <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n    <![endif]-->\n```\n两个<script></script>标签中的src属性所指向的文件链接地址为固定地址中的文件，直接异地引用就好，不用下载到本地引用。\n\n5.设置IE的渲染方式为最高：\n现在有很多人的IE浏览器都升级到IE9以上，这个时候会有很多诡异的事情发生，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8，为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新：\n```\n<meta http-equiv=\"X-UA-Compatible\"content=\"IE=edge\">\n```\n当然还有一个更给力的写法：\n```\n<meta http-equiv=\"X-UA-Compatible\"content=\"IE=Edge，chrome=1\">\n```\n这段代码后面加了一个chrome=1，这是由于Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果用户电脑安装这个chrome插件，就可让电脑内的IE浏览器规避版本因素，使用Webkit引擎及V8引擎进行排版及运算。当然如果用户没装这个插件，这段代码就会让IE浏览器以最高的文档模式展现效果。\n\n6.CSS3 media 媒体查询的写法：\n```\n@media screen and (max-width: 960px){body{background:#000;}}\n```\n这是一个media的标准写法，在CSS文件中，意为：当页面小于960px时执行以下CSS代码，具体内容暂不用管。\n对于上述代码中的screen，意为在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。目前很多网站都会直接省略screen,从而不需要考虑用户打印网页的需求，所以又有这种写法：\n```\n@media (max-width: 960px){\n    body{background:#000;}\n}\n```\n本着思维严谨的原则，一般不采用这种写法。\n\n7.CSS3媒体查询主体代码组合：\n在响应式网页布局中需要持续运用媒体查询代码组合，主要作用在于判断所适配屏幕的宽度，并根据各种宽度条件套用不同的CSS样式。\n- 如当屏幕宽度等于960px时，将网页背景色变为红色：\n```\n@media screen and (max-device-width:960px){\n    body{background:red;}\n}\n```\n\n- 如当屏幕宽度最大为960px（小于960px）时，将网页背景色变为黑色：\n```\n@media screen and (max-width: 960px){\n    body{background:#000;}\n}\n```\n\n- 如当屏幕宽度最小为960px（大于960px）时，将网页背景色变为桔色：\n```\n@media screen and (min-width:960px){\n    body{background:orange;}\n}\n```\n\n- 更为常见的是混合使用，如当屏幕宽度介于960px和1200px之间时，将网页背景色变为黄色：\n```\n@media screen and (min-width:960px) and(max-width:1200px){\n    body{background:yellow;}\n}\n```\n\n8.media媒体查询所有参数汇总：\n媒体查询器中还包含并不常用的相关功能，悉如示下：\nwidth:浏览器可视宽度，\nheight:浏览器可视高度，\ndevice-width:设备屏幕的宽度，\ndevice-height:设备屏幕的高度，\norientation:检测设备目前处于横向还是纵向状态，\naspect-ratio:检测浏览器可视宽度和高度的比例(例如：aspect-ratio:16/9)，\ndevice-aspect-ratio:检测设备的宽度和高度的比例，\ncolor:检测颜色的位数（例如：min-color:32就会检测设备是否拥有32位颜色），\ncolor-index:检查设备颜色索引表中的颜色（他的值不能是负数），\nmonochrome:检测单色楨缓冲区域中的每个像素的位数（这个太高级，估计咱很少会用的到），\nresolution:检测屏幕或打印机的分辨率(例如：min-resolution:300dpi或min-resolution:118dpcm)，\ngrid：检测输出的设备是网格的还是位图设备。\n\n9.扩展——在CSS2中同样有媒体查询：\nmedia媒体查询并不是CSS3诞生之后的专用功能，早在CSS2开始就已经支持media，比如：\n在HTML文件中的<head></head>标签中写入这句：\n```\n<link rel=\"stylesheet\"type=\"text/css\" media=\"screen\"href=\"style.css\">\n```\n以上是CSS2实现的衬线用法，href属性中写入在某单一显示设备中链接的CSS文件，但仅供入门，\n如要判断移动设备是否为纵向放置的显示屏，可以这样写：\n```\n<link rel=\"stylesheet\" type=\"text/css\"media=\"screen and (orientation:portrait)\"href=\"style.css\">\n```\n如要让小于960px的页面执行指定的CSS样式文件，可以这样写：\n```\n<link rel=\"stylesheet\"type=\"text/css\" media=\"screen and (max-width:960px)\"href=\"style.css\">\n```\nCSS2中的媒体查询方法放到现在并不推荐使用，最大的弊端在于这样会增加页面http的请求次数，增加页面负担，使用CSS3中的媒体查询才是目前的最佳方法。\n\n---\n### 二.移动端rem适配\n---\n1.设计思路:\nrem是css3相对根节点(html)的字体大小的单位,通过设备宽度算出每个rem所对应的px,来实现动态适配.\n\n2.动态设置html的font-size,根据参照的设备宽度设置1rem = ?px;\n屏幕的总宽度即为(均分份数)16rem.\n```\nvar html = document.documentElement;\nvar width = html.getBoundingClientRect().width;     //设备尺寸绝对宽度(width = window.screen.width)\nhtml.style.fontSize = width / 16 + 'px';            //将屏幕分成16份：iphone5下（320/16） 1rem = 20px;\n//html.style.fontSize = width / 15 + 'px';          //将屏幕分成15份：iphone6下（375/15） 1rem = 25px;\n//html.style.fontSize = width / 18 + 'px';          //将屏幕分成15份：iphone6s调试\n```\n\n3.编写样式时,所有的尺寸单位均使用rem即可,实际开发中可使用编辑器的转换插件将px转成对应的rem值.\n\n---\n[【查看源码】](https://github.com/HoldCast/resposive)","slug":"responseLayout","published":1,"date":"2017-11-24T01:50:56.835Z","updated":"2017-11-24T01:50:56.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjan9rqbj000u10tolhqzt78p","content":"<p>前端响应式开发包括两个方向,web(pc)端的页面显示和移动端的页面显示,一般页面内容比较少,布局相对简单的页面可以直接采用媒体查询的方式来实现响应式;<br>移动端和PC端需要展示不同的页面样式风格的页面,可以采用pc端响应式,移动端自动适配的方案.<br>1.响应式布局 2.移动端适配-rem</p>\n<blockquote>\n<p>不同的需求,采用不同的方案</p>\n</blockquote>\n<h3 id=\"一-响应式布局\"><a href=\"#一-响应式布局\" class=\"headerlink\" title=\"一.响应式布局\"></a>一.响应式布局</h3><p>1.设计思路：<br>使用CSS3中媒体查询的大致思路就是判断网页在不同设备中所处的宽度范围，这样的范围可能有三种（PC、平板、手机），也可能有四种（PC、平板、中大屏手机、小屏手机），当然也可能只需要两种（平板、手机，PC端单独开发一版时可不作为CSS3媒体查询的使用对象），并为各种宽度范围情况下的所需页面元素套用不同的CSS样式，从而适配各种设备。</p>\n<a id=\"more\"></a>\n<p>2.响应式网页开发中的宽度问题：<br>在实际开发中，通常需要设置响应式网页宽度的最大值，一旦忽略最大宽度，臃肿或零散的网页布局都会造成视觉洪灾，也就是我们常说的看起来很low。<br>目前最为常见的宽度基本上都是：大于或等于960px的PC端（1920px、1600px、1440px、1280px、1140px、960px）、960px至640px之间的平板端（768px、640px）以及640px以下的手机端（480px、320px），以上宽度存在已久，且显示设备中的网页宽度会长期处于这样的状态下，在响应式网页宽度设计上，基本从这几个尺寸考虑就已经足够。</p>\n<p>3.初始化设置：<br>在HTML文件中，网页顶部<head></head>标签中插入一句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这句话在于对响应式网页做一个初始化设置，主要包括：<br>name=”viewport”：标记显示设备为视口；<br>width = device-width：宽度等于当前设备的宽度；<br>initial-scale：初始的缩放比例（默认设置为1.0）；<br>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）；<br>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）；<br>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）。</p>\n<p>4.解决IE浏览器的兼容性问题：<br>因为IE浏览器(IE8)不支持HTML5和CSS3中的media，所以要加载用于解决IE浏览器兼容性问题的JS文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--[if lt IE 9]&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p>\n<p>两个<script></script>标签中的src属性所指向的文件链接地址为固定地址中的文件，直接异地引用就好，不用下载到本地引用。</p>\n<p>5.设置IE的渲染方式为最高：<br>现在有很多人的IE浏览器都升级到IE9以上，这个时候会有很多诡异的事情发生，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8，为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot;content=&quot;IE=edge&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当然还有一个更给力的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot;content=&quot;IE=Edge，chrome=1&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码后面加了一个chrome=1，这是由于Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果用户电脑安装这个chrome插件，就可让电脑内的IE浏览器规避版本因素，使用Webkit引擎及V8引擎进行排版及运算。当然如果用户没装这个插件，这段代码就会让IE浏览器以最高的文档模式展现效果。</p>\n<p>6.CSS3 media 媒体查询的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 960px)&#123;body&#123;background:#000;&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个media的标准写法，在CSS文件中，意为：当页面小于960px时执行以下CSS代码，具体内容暂不用管。<br>对于上述代码中的screen，意为在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。目前很多网站都会直接省略screen,从而不需要考虑用户打印网页的需求，所以又有这种写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (max-width: 960px)&#123;</span><br><span class=\"line\">    body&#123;background:#000;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本着思维严谨的原则，一般不采用这种写法。</p>\n<p>7.CSS3媒体查询主体代码组合：<br>在响应式网页布局中需要持续运用媒体查询代码组合，主要作用在于判断所适配屏幕的宽度，并根据各种宽度条件套用不同的CSS样式。</p>\n<ul>\n<li><p>如当屏幕宽度等于960px时，将网页背景色变为红色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-device-width:960px)&#123;</span><br><span class=\"line\">    body&#123;background:red;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如当屏幕宽度最大为960px（小于960px）时，将网页背景色变为黑色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 960px)&#123;</span><br><span class=\"line\">    body&#123;background:#000;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如当屏幕宽度最小为960px（大于960px）时，将网页背景色变为桔色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width:960px)&#123;</span><br><span class=\"line\">    body&#123;background:orange;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更为常见的是混合使用，如当屏幕宽度介于960px和1200px之间时，将网页背景色变为黄色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width:960px) and(max-width:1200px)&#123;</span><br><span class=\"line\">    body&#123;background:yellow;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>8.media媒体查询所有参数汇总：<br>媒体查询器中还包含并不常用的相关功能，悉如示下：<br>width:浏览器可视宽度，<br>height:浏览器可视高度，<br>device-width:设备屏幕的宽度，<br>device-height:设备屏幕的高度，<br>orientation:检测设备目前处于横向还是纵向状态，<br>aspect-ratio:检测浏览器可视宽度和高度的比例(例如：aspect-ratio:16/9)，<br>device-aspect-ratio:检测设备的宽度和高度的比例，<br>color:检测颜色的位数（例如：min-color:32就会检测设备是否拥有32位颜色），<br>color-index:检查设备颜色索引表中的颜色（他的值不能是负数），<br>monochrome:检测单色楨缓冲区域中的每个像素的位数（这个太高级，估计咱很少会用的到），<br>resolution:检测屏幕或打印机的分辨率(例如：min-resolution:300dpi或min-resolution:118dpcm)，<br>grid：检测输出的设备是网格的还是位图设备。</p>\n<p>9.扩展——在CSS2中同样有媒体查询：<br>media媒体查询并不是CSS3诞生之后的专用功能，早在CSS2开始就已经支持media，比如：<br>在HTML文件中的<head></head>标签中写入这句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; media=&quot;screen&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以上是CSS2实现的衬线用法，href属性中写入在某单一显示设备中链接的CSS文件，但仅供入门，<br>如要判断移动设备是否为纵向放置的显示屏，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;media=&quot;screen and (orientation:portrait)&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如要让小于960px的页面执行指定的CSS样式文件，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; media=&quot;screen and (max-width:960px)&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS2中的媒体查询方法放到现在并不推荐使用，最大的弊端在于这样会增加页面http的请求次数，增加页面负担，使用CSS3中的媒体查询才是目前的最佳方法。</p>\n<hr>\n<h3 id=\"二-移动端rem适配\"><a href=\"#二-移动端rem适配\" class=\"headerlink\" title=\"二.移动端rem适配\"></a>二.移动端rem适配</h3><hr>\n<p>1.设计思路:<br>rem是css3相对根节点(html)的字体大小的单位,通过设备宽度算出每个rem所对应的px,来实现动态适配.</p>\n<p>2.动态设置html的font-size,根据参照的设备宽度设置1rem = ?px;<br>屏幕的总宽度即为(均分份数)16rem.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var html = document.documentElement;</span><br><span class=\"line\">var width = html.getBoundingClientRect().width;     //设备尺寸绝对宽度(width = window.screen.width)</span><br><span class=\"line\">html.style.fontSize = width / 16 + &apos;px&apos;;            //将屏幕分成16份：iphone5下（320/16） 1rem = 20px;</span><br><span class=\"line\">//html.style.fontSize = width / 15 + &apos;px&apos;;          //将屏幕分成15份：iphone6下（375/15） 1rem = 25px;</span><br><span class=\"line\">//html.style.fontSize = width / 18 + &apos;px&apos;;          //将屏幕分成15份：iphone6s调试</span><br></pre></td></tr></table></figure></p>\n<p>3.编写样式时,所有的尺寸单位均使用rem即可,实际开发中可使用编辑器的转换插件将px转成对应的rem值.</p>\n<hr>\n<p><a href=\"https://github.com/HoldCast/resposive\" target=\"_blank\" rel=\"noopener\">【查看源码】</a></p>\n","site":{"data":{}},"excerpt":"<p>前端响应式开发包括两个方向,web(pc)端的页面显示和移动端的页面显示,一般页面内容比较少,布局相对简单的页面可以直接采用媒体查询的方式来实现响应式;<br>移动端和PC端需要展示不同的页面样式风格的页面,可以采用pc端响应式,移动端自动适配的方案.<br>1.响应式布局 2.移动端适配-rem</p>\n<blockquote>\n<p>不同的需求,采用不同的方案</p>\n</blockquote>\n<h3 id=\"一-响应式布局\"><a href=\"#一-响应式布局\" class=\"headerlink\" title=\"一.响应式布局\"></a>一.响应式布局</h3><p>1.设计思路：<br>使用CSS3中媒体查询的大致思路就是判断网页在不同设备中所处的宽度范围，这样的范围可能有三种（PC、平板、手机），也可能有四种（PC、平板、中大屏手机、小屏手机），当然也可能只需要两种（平板、手机，PC端单独开发一版时可不作为CSS3媒体查询的使用对象），并为各种宽度范围情况下的所需页面元素套用不同的CSS样式，从而适配各种设备。</p>","more":"<p>2.响应式网页开发中的宽度问题：<br>在实际开发中，通常需要设置响应式网页宽度的最大值，一旦忽略最大宽度，臃肿或零散的网页布局都会造成视觉洪灾，也就是我们常说的看起来很low。<br>目前最为常见的宽度基本上都是：大于或等于960px的PC端（1920px、1600px、1440px、1280px、1140px、960px）、960px至640px之间的平板端（768px、640px）以及640px以下的手机端（480px、320px），以上宽度存在已久，且显示设备中的网页宽度会长期处于这样的状态下，在响应式网页宽度设计上，基本从这几个尺寸考虑就已经足够。</p>\n<p>3.初始化设置：<br>在HTML文件中，网页顶部<head></head>标签中插入一句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这句话在于对响应式网页做一个初始化设置，主要包括：<br>name=”viewport”：标记显示设备为视口；<br>width = device-width：宽度等于当前设备的宽度；<br>initial-scale：初始的缩放比例（默认设置为1.0）；<br>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）；<br>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）；<br>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）。</p>\n<p>4.解决IE浏览器的兼容性问题：<br>因为IE浏览器(IE8)不支持HTML5和CSS3中的media，所以要加载用于解决IE浏览器兼容性问题的JS文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--[if lt IE 9]&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p>\n<p>两个<script></script>标签中的src属性所指向的文件链接地址为固定地址中的文件，直接异地引用就好，不用下载到本地引用。</p>\n<p>5.设置IE的渲染方式为最高：<br>现在有很多人的IE浏览器都升级到IE9以上，这个时候会有很多诡异的事情发生，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8，为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot;content=&quot;IE=edge&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当然还有一个更给力的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot;content=&quot;IE=Edge，chrome=1&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码后面加了一个chrome=1，这是由于Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果用户电脑安装这个chrome插件，就可让电脑内的IE浏览器规避版本因素，使用Webkit引擎及V8引擎进行排版及运算。当然如果用户没装这个插件，这段代码就会让IE浏览器以最高的文档模式展现效果。</p>\n<p>6.CSS3 media 媒体查询的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 960px)&#123;body&#123;background:#000;&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个media的标准写法，在CSS文件中，意为：当页面小于960px时执行以下CSS代码，具体内容暂不用管。<br>对于上述代码中的screen，意为在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。目前很多网站都会直接省略screen,从而不需要考虑用户打印网页的需求，所以又有这种写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (max-width: 960px)&#123;</span><br><span class=\"line\">    body&#123;background:#000;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本着思维严谨的原则，一般不采用这种写法。</p>\n<p>7.CSS3媒体查询主体代码组合：<br>在响应式网页布局中需要持续运用媒体查询代码组合，主要作用在于判断所适配屏幕的宽度，并根据各种宽度条件套用不同的CSS样式。</p>\n<ul>\n<li><p>如当屏幕宽度等于960px时，将网页背景色变为红色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-device-width:960px)&#123;</span><br><span class=\"line\">    body&#123;background:red;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如当屏幕宽度最大为960px（小于960px）时，将网页背景色变为黑色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 960px)&#123;</span><br><span class=\"line\">    body&#123;background:#000;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如当屏幕宽度最小为960px（大于960px）时，将网页背景色变为桔色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width:960px)&#123;</span><br><span class=\"line\">    body&#123;background:orange;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更为常见的是混合使用，如当屏幕宽度介于960px和1200px之间时，将网页背景色变为黄色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width:960px) and(max-width:1200px)&#123;</span><br><span class=\"line\">    body&#123;background:yellow;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>8.media媒体查询所有参数汇总：<br>媒体查询器中还包含并不常用的相关功能，悉如示下：<br>width:浏览器可视宽度，<br>height:浏览器可视高度，<br>device-width:设备屏幕的宽度，<br>device-height:设备屏幕的高度，<br>orientation:检测设备目前处于横向还是纵向状态，<br>aspect-ratio:检测浏览器可视宽度和高度的比例(例如：aspect-ratio:16/9)，<br>device-aspect-ratio:检测设备的宽度和高度的比例，<br>color:检测颜色的位数（例如：min-color:32就会检测设备是否拥有32位颜色），<br>color-index:检查设备颜色索引表中的颜色（他的值不能是负数），<br>monochrome:检测单色楨缓冲区域中的每个像素的位数（这个太高级，估计咱很少会用的到），<br>resolution:检测屏幕或打印机的分辨率(例如：min-resolution:300dpi或min-resolution:118dpcm)，<br>grid：检测输出的设备是网格的还是位图设备。</p>\n<p>9.扩展——在CSS2中同样有媒体查询：<br>media媒体查询并不是CSS3诞生之后的专用功能，早在CSS2开始就已经支持media，比如：<br>在HTML文件中的<head></head>标签中写入这句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; media=&quot;screen&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以上是CSS2实现的衬线用法，href属性中写入在某单一显示设备中链接的CSS文件，但仅供入门，<br>如要判断移动设备是否为纵向放置的显示屏，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;media=&quot;screen and (orientation:portrait)&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如要让小于960px的页面执行指定的CSS样式文件，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; media=&quot;screen and (max-width:960px)&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS2中的媒体查询方法放到现在并不推荐使用，最大的弊端在于这样会增加页面http的请求次数，增加页面负担，使用CSS3中的媒体查询才是目前的最佳方法。</p>\n<hr>\n<h3 id=\"二-移动端rem适配\"><a href=\"#二-移动端rem适配\" class=\"headerlink\" title=\"二.移动端rem适配\"></a>二.移动端rem适配</h3><hr>\n<p>1.设计思路:<br>rem是css3相对根节点(html)的字体大小的单位,通过设备宽度算出每个rem所对应的px,来实现动态适配.</p>\n<p>2.动态设置html的font-size,根据参照的设备宽度设置1rem = ?px;<br>屏幕的总宽度即为(均分份数)16rem.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var html = document.documentElement;</span><br><span class=\"line\">var width = html.getBoundingClientRect().width;     //设备尺寸绝对宽度(width = window.screen.width)</span><br><span class=\"line\">html.style.fontSize = width / 16 + &apos;px&apos;;            //将屏幕分成16份：iphone5下（320/16） 1rem = 20px;</span><br><span class=\"line\">//html.style.fontSize = width / 15 + &apos;px&apos;;          //将屏幕分成15份：iphone6下（375/15） 1rem = 25px;</span><br><span class=\"line\">//html.style.fontSize = width / 18 + &apos;px&apos;;          //将屏幕分成15份：iphone6s调试</span><br></pre></td></tr></table></figure></p>\n<p>3.编写样式时,所有的尺寸单位均使用rem即可,实际开发中可使用编辑器的转换插件将px转成对应的rem值.</p>\n<hr>\n<p><a href=\"https://github.com/HoldCast/resposive\" target=\"_blank\" rel=\"noopener\">【查看源码】</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjan9rq9p000010totfutit0z","tag_id":"cjan9rqag000310to9w9yapte","_id":"cjan9rqav000910toh5aqwwov"},{"post_id":"cjan9rq9p000010totfutit0z","tag_id":"cjan9rqat000710toaxk19mow","_id":"cjan9rqav000a10to8g0693r1"},{"post_id":"cjan9rqac000210tofo0ugao5","tag_id":"cjan9rqau000810to4ipvd03y","_id":"cjan9rqaw000c10tops1z85mv"},{"post_id":"cjan9rqaj000410tobfa8adbd","tag_id":"cjan9rqav000b10tohc8qh8ia","_id":"cjan9rqaz000g10tohdfrg1le"},{"post_id":"cjan9rqaj000410tobfa8adbd","tag_id":"cjan9rqax000d10to4hn5d5t5","_id":"cjan9rqaz000h10todqvsrigh"},{"post_id":"cjan9rqaj000410tobfa8adbd","tag_id":"cjan9rqay000e10tokxox0da4","_id":"cjan9rqaz000j10toan67jdlw"},{"post_id":"cjan9rqap000510to0lct40y5","tag_id":"cjan9rqay000f10tokfmwp38k","_id":"cjan9rqb2000m10tocm3r21rv"},{"post_id":"cjan9rqap000510to0lct40y5","tag_id":"cjan9rqaz000i10tobwv5rti9","_id":"cjan9rqb2000n10toq3mjk85a"},{"post_id":"cjan9rqap000510to0lct40y5","tag_id":"cjan9rqb0000k10tofb3qh0b1","_id":"cjan9rqb3000p10tob36vcte8"},{"post_id":"cjan9rqar000610to8qbm61ky","tag_id":"cjan9rqay000f10tokfmwp38k","_id":"cjan9rqb3000q10toukxwcpel"},{"post_id":"cjan9rqar000610to8qbm61ky","tag_id":"cjan9rqb2000o10tomkx79pj6","_id":"cjan9rqb3000r10to41rr3b4q"},{"post_id":"cjan9rqbd000s10toze5k0wpf","tag_id":"cjan9rqay000f10tokfmwp38k","_id":"cjan9rqbk000w10to1pmd1vmp"},{"post_id":"cjan9rqbj000u10tolhqzt78p","tag_id":"cjan9rqax000d10to4hn5d5t5","_id":"cjan9rqbp001010to7r16i35l"},{"post_id":"cjan9rqbj000u10tolhqzt78p","tag_id":"cjan9rqbn000y10to1qzpxale","_id":"cjan9rqbp001110tocudpyd4u"},{"post_id":"cjan9rqbj000u10tolhqzt78p","tag_id":"cjan9rqbo000z10to54eia34b","_id":"cjan9rqbp001210to480ph043"}],"Tag":[{"name":"javascript","_id":"cjan9rqag000310to9w9yapte"},{"name":"类型判断","_id":"cjan9rqat000710toaxk19mow"},{"name":"guide","_id":"cjan9rqau000810to4ipvd03y"},{"name":"bootstrap","_id":"cjan9rqav000b10tohc8qh8ia"},{"name":"响应式","_id":"cjan9rqax000d10to4hn5d5t5"},{"name":"metro","_id":"cjan9rqay000e10tokxox0da4"},{"name":"http","_id":"cjan9rqay000f10tokfmwp38k"},{"name":"header","_id":"cjan9rqaz000i10tobwv5rti9"},{"name":"服务器时间","_id":"cjan9rqb0000k10tofb3qh0b1"},{"name":"状态码","_id":"cjan9rqb2000o10tomkx79pj6"},{"name":"移动适配","_id":"cjan9rqbn000y10to1qzpxale"},{"name":"rem","_id":"cjan9rqbo000z10to54eia34b"}]}}