{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia2/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia2/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"source/assets/img/favicon.ico","path":"assets/img/favicon.ico","modified":1,"renderable":0},{"_id":"source/assets/img/http-lc.png","path":"assets/img/http-lc.png","modified":1,"renderable":0},{"_id":"source/assets/img/header.png","path":"assets/img/header.png","modified":1,"renderable":0},{"_id":"source/assets/img/log.jpg","path":"assets/img/log.jpg","modified":1,"renderable":0},{"_id":"themes/yilia2/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"source/assets/img/bootstrapMetro.png","path":"assets/img/bootstrapMetro.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia2/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1542618259994},{"_id":"themes/yilia2/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1542618259994},{"_id":"themes/yilia2/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1542618259995},{"_id":"themes/yilia2/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1542618259995},{"_id":"themes/yilia2/README.md","hash":"99985dc9f0f3473a26341245e436751bc42fd322","modified":1542618259995},{"_id":"themes/yilia2/_config.yml","hash":"0c669187283220f90e76e83f968d49866422b467","modified":1542618259995},{"_id":"themes/yilia2/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1542618260007},{"_id":"themes/yilia2/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1542618260035},{"_id":"source/_posts/JavaScript - 类型判断.md","hash":"337c5ab4337b8846e28b4175cee26d6c30f3d51a","modified":1542618259959},{"_id":"source/_posts/hello-world.md","hash":"e7b2192769b708103c0bfabecea36b666cf7d716","modified":1542618259959},{"_id":"source/_posts/http-headers.md","hash":"9ff2afea7407d0de46be0f7245df9b2ba7a72c1b","modified":1542618259959},{"_id":"source/_posts/bootstrap-metro.md","hash":"1cfc0243eec27c570e6d2a0b2267cef144cf0a2e","modified":1542618259959},{"_id":"source/_posts/http-status.md","hash":"e87ae5ba799422bb1de093d33b9e8d292a9c2fa9","modified":1542618259960},{"_id":"source/_posts/http.md","hash":"e12011ecb617ad501fac7e30e066ca3b86332996","modified":1542618259960},{"_id":"source/_posts/responseLayout.md","hash":"414597d6d7f289cc317617a8cb4d380f4238af26","modified":1542618259961},{"_id":"source/_posts/websoket.md","hash":"e12011ecb617ad501fac7e30e066ca3b86332996","modified":1542618259000},{"_id":"source/_posts/websocket.md","hash":"9de090792675830f0c4e5b37cf9dded88b2463f8","modified":1542619121044},{"_id":"source/menu/index.md","hash":"8724da9128aef88e12a6e49c551a09158a5194a6","modified":1542618259963},{"_id":"source/public/2.md","hash":"b1017ab1177d72528be39841a24e2f9f459b2b36","modified":1542618259963},{"_id":"source/public/index.md","hash":"c760ac9927e040e2a28cf1c34b772d2ffe0a4b25","modified":1542618259963},{"_id":"source/tags/index.md","hash":"d1aa193f45b7f2f65439131a45de0b6aa6212a5c","modified":1542618259963},{"_id":"themes/yilia2/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1542618259996},{"_id":"themes/yilia2/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1542618259996},{"_id":"themes/yilia2/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1542618259996},{"_id":"themes/yilia2/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1542618259996},{"_id":"themes/yilia2/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1542618259997},{"_id":"themes/yilia2/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1542618259997},{"_id":"themes/yilia2/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1542618259997},{"_id":"themes/yilia2/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1542618260006},{"_id":"themes/yilia2/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1542618260006},{"_id":"themes/yilia2/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1542618260006},{"_id":"themes/yilia2/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1542618260006},{"_id":"themes/yilia2/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1542618260007},{"_id":"themes/yilia2/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1542618260007},{"_id":"themes/yilia2/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1542618260007},{"_id":"themes/yilia2/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1542618260031},{"_id":"themes/yilia2/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1542618260034},{"_id":"themes/yilia2/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1542618260008},{"_id":"themes/yilia2/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1542618260024},{"_id":"themes/yilia2/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542618260005},{"_id":"themes/yilia2/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1542618260032},{"_id":"themes/yilia2/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1542618260033},{"_id":"source/assets/img/favicon.ico","hash":"d33cddcbbbbb16c1c1fed6d40f23097a27708adf","modified":1542618259962},{"_id":"source/assets/img/http-lc.png","hash":"9df27f26ae5cca68ff1fe817ab6c122a33b8f9d3","modified":1542618259962},{"_id":"source/assets/img/header.png","hash":"e4eea11e1656950b44ddb6c736b74688ea874ac2","modified":1542618259962},{"_id":"source/assets/img/log.jpg","hash":"c0078e8d9ab23f187652865b67431ceb99d46c97","modified":1542618259963},{"_id":"themes/yilia2/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1542618259998},{"_id":"themes/yilia2/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1542618259998},{"_id":"themes/yilia2/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1542618259998},{"_id":"themes/yilia2/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1542618259998},{"_id":"themes/yilia2/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1542618259998},{"_id":"themes/yilia2/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1542618259999},{"_id":"themes/yilia2/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1542618259999},{"_id":"themes/yilia2/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1542618259999},{"_id":"themes/yilia2/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1542618260000},{"_id":"themes/yilia2/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1542618259999},{"_id":"themes/yilia2/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1542618260000},{"_id":"themes/yilia2/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1542618260000},{"_id":"themes/yilia2/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1542618260000},{"_id":"themes/yilia2/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1542618260001},{"_id":"themes/yilia2/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1542618260005},{"_id":"themes/yilia2/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1542618260006},{"_id":"themes/yilia2/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1542618260025},{"_id":"themes/yilia2/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1542618260026},{"_id":"themes/yilia2/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1542618260027},{"_id":"themes/yilia2/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1542618260027},{"_id":"themes/yilia2/source/fonts/tooltip.4004ff.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1542618260028},{"_id":"themes/yilia2/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1542618260028},{"_id":"themes/yilia2/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1542618260029},{"_id":"themes/yilia2/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1542618260030},{"_id":"themes/yilia2/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1542618260030},{"_id":"themes/yilia2/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1542618260008},{"_id":"themes/yilia2/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1542618260008},{"_id":"themes/yilia2/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1542618260009},{"_id":"themes/yilia2/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1542618260009},{"_id":"themes/yilia2/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1542618260009},{"_id":"themes/yilia2/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1542618260009},{"_id":"themes/yilia2/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1542618260010},{"_id":"themes/yilia2/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1542618260010},{"_id":"themes/yilia2/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1542618260010},{"_id":"themes/yilia2/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1542618260012},{"_id":"themes/yilia2/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1542618260014},{"_id":"themes/yilia2/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1542618260014},{"_id":"themes/yilia2/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1542618260015},{"_id":"themes/yilia2/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1542618260015},{"_id":"themes/yilia2/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1542618260016},{"_id":"themes/yilia2/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1542618260016},{"_id":"themes/yilia2/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1542618260016},{"_id":"themes/yilia2/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1542618260017},{"_id":"themes/yilia2/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1542618260017},{"_id":"themes/yilia2/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1542618260017},{"_id":"themes/yilia2/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1542618260017},{"_id":"themes/yilia2/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1542618260018},{"_id":"themes/yilia2/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1542618260018},{"_id":"themes/yilia2/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1542618260018},{"_id":"themes/yilia2/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1542618260018},{"_id":"themes/yilia2/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1542618260019},{"_id":"themes/yilia2/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1542618260019},{"_id":"themes/yilia2/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1542618260020},{"_id":"themes/yilia2/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1542618260020},{"_id":"themes/yilia2/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1542618260021},{"_id":"themes/yilia2/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1542618260021},{"_id":"themes/yilia2/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1542618260020},{"_id":"themes/yilia2/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1542618260022},{"_id":"themes/yilia2/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1542618260022},{"_id":"themes/yilia2/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1542618260022},{"_id":"themes/yilia2/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1542618260023},{"_id":"themes/yilia2/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1542618260023},{"_id":"themes/yilia2/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1542618260024},{"_id":"themes/yilia2/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1542618260024},{"_id":"source/assets/img/bootstrapMetro.png","hash":"2be5346ac6927f87f9cc951435041f44ad90a402","modified":1542618259961},{"_id":"themes/yilia2/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1542618260004},{"_id":"themes/yilia2/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1542618260001},{"_id":"themes/yilia2/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1542618260001},{"_id":"themes/yilia2/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1542618260001},{"_id":"themes/yilia2/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1542618260002},{"_id":"themes/yilia2/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1542618260002},{"_id":"themes/yilia2/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1542618260002},{"_id":"themes/yilia2/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1542618260003},{"_id":"themes/yilia2/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1542618260003},{"_id":"themes/yilia2/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1542618260003},{"_id":"themes/yilia2/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1542618260003},{"_id":"themes/yilia2/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1542618260011},{"_id":"themes/yilia2/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1542618260011},{"_id":"themes/yilia2/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1542618260011},{"_id":"themes/yilia2/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1542618260012},{"_id":"themes/yilia2/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1542618260012},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1542618260013},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1542618260013},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1542618260014},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1542618260013},{"_id":"themes/yilia2/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1542618260015},{"_id":"themes/yilia2/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1542618260015},{"_id":"themes/yilia2/source-src/css/img/tooltip.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1542618260016}],"Category":[],"Data":[],"Page":[{"title":"menu","_content":"","source":"menu/index.md","raw":"---\ntitle: menu\n---","date":"2018-11-19T09:04:19.963Z","updated":"2018-11-19T09:04:19.963Z","path":"menu/index.html","comments":1,"layout":"page","_id":"cjoo58bx90017natfy9fk67xl","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"2222222222","source":"public/2.md","raw":"2222222222","date":"2018-11-19T09:04:19.963Z","updated":"2018-11-19T09:04:19.963Z","path":"public/2.html","title":"","comments":1,"layout":"page","_id":"cjoo58bxa0018natfrksc00ne","content":"<p>2222222222</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2222222222</p>\n"},{"_content":"title: public\ntags:\n  - public","source":"public/index.md","raw":"title: public\ntags:\n  - public","date":"2018-11-19T09:04:19.963Z","updated":"2018-11-19T09:04:19.963Z","path":"public/index.html","title":"","comments":1,"layout":"page","_id":"cjoo58bxb0019natfitye4ss2","content":"<p>title: public<br>tags:</p>\n<ul>\n<li>public</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>title: public<br>tags:</p>\n<ul>\n<li>public</li>\n</ul>\n"},{"title":"tags","date":"2015-12-02T04:10:34.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-12-02 12:10:34\ntype: \"tags\"\n---","updated":"2018-11-19T09:04:19.963Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjoo58bxb001anatfnya59wwv","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JavaScript - 对象类型判断","_content":"- typeof 判断\n- instanceof 运算符\n- constructor 属性\n- Object.prototype.toString() 判断\n\n<!-- more -->\n### 1.typeof 判断\n在区别对象和原始类型的时候可使用这种判断方法,其返回值有:\"number\"，\"string\"，\"boolean\"，\"object\"，\"function\"，\"undefined\"（可用于判断变量是否存在）.\n但typeof有局限，其对于null、{}、[]、Date、RegExp等类型返回的都是\"object\"。如：\ntypeof {}; // object\ntypeof []; // object\ntypeof null; // object\ntypeof new Date(); // object;\n\n### 2.instanceof 运算符\ninstanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。\n如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。如：\n[] instanceof Array; // true\n[] instanceof Object; // true\n[] instanceof RegExp; // false\nnew Date instanceof Date; // true\n *可以用instanceof运算符来判断对象是否为数组类型.*\n\n### 3.constructor 属性\nJavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。\n通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。所以判断数组的函数也可以这样写：\nfunction isArray(arr){\n  return typeof arr == \"object\" && arr.constructor == Array;\n}\n\n### 4.Object.prototype.toString() 判断\n** \\*这种方法可以准确判断各种数据类型\\* **\nObject.prototype.toString.call([]); // \"[object Array]\"\nObject.prototype.toString.call(/reg/ig); // \"[object RegExp]\"\nObject.prototype.toString.call(999); // \"[object Number]\"\n用于检测各种对象类型：\n```\nvar is ={\n  types : [\"Array\", \"Boolean\", \"Date\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Window\", \"HTMLDocument\"]\n};\nfor(var i = 0, c; c = is.types[i ++ ]; ){\n  is[c] = (function(type){\n    return function(obj){\n      return Object.prototype.toString.call(obj) == \"[object \" + type + \"]\";\n    }\n  )(c);\n}\nalert(is.Array([])); // true\nalert(is.Date(new Date)); // true\nalert(is.RegExp(/reg/ig)); // true\n//...\n```","source":"_posts/JavaScript - 类型判断.md","raw":"title: JavaScript - 对象类型判断\ntags:\n    - javascript\n    - 类型判断\n---\n- typeof 判断\n- instanceof 运算符\n- constructor 属性\n- Object.prototype.toString() 判断\n\n<!-- more -->\n### 1.typeof 判断\n在区别对象和原始类型的时候可使用这种判断方法,其返回值有:\"number\"，\"string\"，\"boolean\"，\"object\"，\"function\"，\"undefined\"（可用于判断变量是否存在）.\n但typeof有局限，其对于null、{}、[]、Date、RegExp等类型返回的都是\"object\"。如：\ntypeof {}; // object\ntypeof []; // object\ntypeof null; // object\ntypeof new Date(); // object;\n\n### 2.instanceof 运算符\ninstanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。\n如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。如：\n[] instanceof Array; // true\n[] instanceof Object; // true\n[] instanceof RegExp; // false\nnew Date instanceof Date; // true\n *可以用instanceof运算符来判断对象是否为数组类型.*\n\n### 3.constructor 属性\nJavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。\n通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。所以判断数组的函数也可以这样写：\nfunction isArray(arr){\n  return typeof arr == \"object\" && arr.constructor == Array;\n}\n\n### 4.Object.prototype.toString() 判断\n** \\*这种方法可以准确判断各种数据类型\\* **\nObject.prototype.toString.call([]); // \"[object Array]\"\nObject.prototype.toString.call(/reg/ig); // \"[object RegExp]\"\nObject.prototype.toString.call(999); // \"[object Number]\"\n用于检测各种对象类型：\n```\nvar is ={\n  types : [\"Array\", \"Boolean\", \"Date\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Window\", \"HTMLDocument\"]\n};\nfor(var i = 0, c; c = is.types[i ++ ]; ){\n  is[c] = (function(type){\n    return function(obj){\n      return Object.prototype.toString.call(obj) == \"[object \" + type + \"]\";\n    }\n  )(c);\n}\nalert(is.Array([])); // true\nalert(is.Date(new Date)); // true\nalert(is.RegExp(/reg/ig)); // true\n//...\n```","slug":"JavaScript - 类型判断","published":1,"date":"2018-11-19T09:04:19.959Z","updated":"2018-11-19T09:04:19.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bwe0000natf7ay3wby6","content":"<ul>\n<li>typeof 判断</li>\n<li>instanceof 运算符</li>\n<li>constructor 属性</li>\n<li>Object.prototype.toString() 判断</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"1-typeof-判断\"><a href=\"#1-typeof-判断\" class=\"headerlink\" title=\"1.typeof 判断\"></a>1.typeof 判断</h3><p>在区别对象和原始类型的时候可使用这种判断方法,其返回值有:”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）.<br>但typeof有局限，其对于null、{}、[]、Date、RegExp等类型返回的都是”object”。如：<br>typeof {}; // object<br>typeof []; // object<br>typeof null; // object<br>typeof new Date(); // object;</p>\n<h3 id=\"2-instanceof-运算符\"><a href=\"#2-instanceof-运算符\" class=\"headerlink\" title=\"2.instanceof 运算符\"></a>2.instanceof 运算符</h3><p>instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。<br>如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。如：<br>[] instanceof Array; // true<br>[] instanceof Object; // true<br>[] instanceof RegExp; // false<br>new Date instanceof Date; // true<br> <em>可以用instanceof运算符来判断对象是否为数组类型.</em></p>\n<h3 id=\"3-constructor-属性\"><a href=\"#3-constructor-属性\" class=\"headerlink\" title=\"3.constructor 属性\"></a>3.constructor 属性</h3><p>JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。<br>通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。所以判断数组的函数也可以这样写：<br>function isArray(arr){<br>  return typeof arr == “object” &amp;&amp; arr.constructor == Array;<br>}</p>\n<h3 id=\"4-Object-prototype-toString-判断\"><a href=\"#4-Object-prototype-toString-判断\" class=\"headerlink\" title=\"4.Object.prototype.toString() 判断\"></a>4.Object.prototype.toString() 判断</h3><p><strong> *这种方法可以准确判断各种数据类型* </strong><br>Object.prototype.toString.call([]); // “[object Array]”<br>Object.prototype.toString.call(/reg/ig); // “[object RegExp]”<br>Object.prototype.toString.call(999); // “[object Number]”<br>用于检测各种对象类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var is =&#123;</span><br><span class=\"line\">  types : [&quot;Array&quot;, &quot;Boolean&quot;, &quot;Date&quot;, &quot;Number&quot;, &quot;Object&quot;, &quot;RegExp&quot;, &quot;String&quot;, &quot;Window&quot;, &quot;HTMLDocument&quot;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">for(var i = 0, c; c = is.types[i ++ ]; )&#123;</span><br><span class=\"line\">  is[c] = (function(type)&#123;</span><br><span class=\"line\">    return function(obj)&#123;</span><br><span class=\"line\">      return Object.prototype.toString.call(obj) == &quot;[object &quot; + type + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(is.Array([])); // true</span><br><span class=\"line\">alert(is.Date(new Date)); // true</span><br><span class=\"line\">alert(is.RegExp(/reg/ig)); // true</span><br><span class=\"line\">//...</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>typeof 判断</li>\n<li>instanceof 运算符</li>\n<li>constructor 属性</li>\n<li>Object.prototype.toString() 判断</li>\n</ul>","more":"<h3 id=\"1-typeof-判断\"><a href=\"#1-typeof-判断\" class=\"headerlink\" title=\"1.typeof 判断\"></a>1.typeof 判断</h3><p>在区别对象和原始类型的时候可使用这种判断方法,其返回值有:”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）.<br>但typeof有局限，其对于null、{}、[]、Date、RegExp等类型返回的都是”object”。如：<br>typeof {}; // object<br>typeof []; // object<br>typeof null; // object<br>typeof new Date(); // object;</p>\n<h3 id=\"2-instanceof-运算符\"><a href=\"#2-instanceof-运算符\" class=\"headerlink\" title=\"2.instanceof 运算符\"></a>2.instanceof 运算符</h3><p>instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。<br>如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。如：<br>[] instanceof Array; // true<br>[] instanceof Object; // true<br>[] instanceof RegExp; // false<br>new Date instanceof Date; // true<br> <em>可以用instanceof运算符来判断对象是否为数组类型.</em></p>\n<h3 id=\"3-constructor-属性\"><a href=\"#3-constructor-属性\" class=\"headerlink\" title=\"3.constructor 属性\"></a>3.constructor 属性</h3><p>JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。<br>通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。所以判断数组的函数也可以这样写：<br>function isArray(arr){<br>  return typeof arr == “object” &amp;&amp; arr.constructor == Array;<br>}</p>\n<h3 id=\"4-Object-prototype-toString-判断\"><a href=\"#4-Object-prototype-toString-判断\" class=\"headerlink\" title=\"4.Object.prototype.toString() 判断\"></a>4.Object.prototype.toString() 判断</h3><p><strong> *这种方法可以准确判断各种数据类型* </strong><br>Object.prototype.toString.call([]); // “[object Array]”<br>Object.prototype.toString.call(/reg/ig); // “[object RegExp]”<br>Object.prototype.toString.call(999); // “[object Number]”<br>用于检测各种对象类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var is =&#123;</span><br><span class=\"line\">  types : [&quot;Array&quot;, &quot;Boolean&quot;, &quot;Date&quot;, &quot;Number&quot;, &quot;Object&quot;, &quot;RegExp&quot;, &quot;String&quot;, &quot;Window&quot;, &quot;HTMLDocument&quot;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">for(var i = 0, c; c = is.types[i ++ ]; )&#123;</span><br><span class=\"line\">  is[c] = (function(type)&#123;</span><br><span class=\"line\">    return function(obj)&#123;</span><br><span class=\"line\">      return Object.prototype.toString.call(obj) == &quot;[object &quot; + type + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(is.Array([])); // true</span><br><span class=\"line\">alert(is.Date(new Date)); // true</span><br><span class=\"line\">alert(is.RegExp(/reg/ig)); // true</span><br><span class=\"line\">//...</span><br></pre></td></tr></table></figure></p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags:\n  - guide\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-11-19T09:04:19.959Z","updated":"2018-11-19T09:04:19.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bwi0001natfby3p2joy","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"前端获取服务器时间及其他Headers信息","_content":"前端页面访问服务器时,获取服务器返回的http请求回来的header信息,如下图:\n![](/assets/img/header.png)\n获取Response Header的方法:\n<!-- more -->\n1.js-ajax方法获取:\n```\nfunction ajax(){\n    var xhr = null;\n    var url = window.location.href;\n    if(window.xhrRequest){\n      xhr = new window.xhrRequest();\n    }else{ // ie\n      xhr = new ActiveObject(\"Microsoft\")\n    }\n    // 通过get的方式请求当前文件\n    xhr.open(\"get\",url,false);  //同步\n    //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。\n    //xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n    //xhr.send(\"fname=Henry&lname=Ford\");\n    xhr.send(null);\n    // 监听请求状态变化 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：\n    xhr.onreadystatechange = function(){\n        //if (xhr.readyState==4 && xhr.status==200)\n        if(xhr.readyState===2){\n            var time = xhr.getResponseHeader(\"Date\");\n            var curDate = new Date(time);\n        }\n    }\n    if (xhr.status === 200) {\n        var time = xhr.getResponseHeader(\"Date\");\n        curDate = new Date(time);\n    }\n\n    //其他ajax相关\n    //xhr.responseText\t获得字符串形式的响应数据。\n    //xhr.responseXML\t获得 XML 形式的响应数据。\n  }\n```\n2.jquery-ajax方法获取:\n```\n$.ajax({\n    type: 'HEAD', // 获取头信息，type=HEAD即可\n    url : window.location.href,\n    complete: function(xhr,data){// 获取相关Http Response header\n        var wpoInfo = {\n            \"date\" : xhr.getResponseHeader('Date'),// 服务器端时间\n            \"contentEncoding\" : xhr.getResponseHeader('Content-Encoding'),// 如果开启了gzip，会返回这个东西\n            \"connection\" : xhr.getResponseHeader('Connection'),// keep-alive ？ close？\n            \"contentLength\" : xhr.getResponseHeader('Content-Length'),// 响应长度\n            \"server\" : xhr.getResponseHeader('Server'),// 服务器类型，apache？lighttpd？\n            \"vary\" : xhr.getResponseHeader('Vary'),\n            \"transferEncoding\" : xhr.getResponseHeader('Transfer-Encoding'),\n            \"contentType\" : xhr.getResponseHeader('Content-Type'),// text/html ? text/xml?\n            \"cacheControl\" : xhr.getResponseHeader('Cache-Control'),\n            \"exprires\" : xhr.getResponseHeader('Exprires'),// 生命周期？\n            \"lastModified\" : xhr.getResponseHeader('Last-Modified')\n        };\n        var curDate = new Date(wpoInfo.date);\n    }\n});\n```\n!!!\n注意:通过header获取的时间是格林威治时间,北京时间与格林威治时间或UTC时间相差8个时区，北京、上海、重庆位于东8区，\n所以北京时间过了8小时,获取之后记得换算成北京时间!!!\n","source":"_posts/http-headers.md","raw":"title: 前端获取服务器时间及其他Headers信息\ntags:\n    - http\n    - header\n    - 服务器时间\n---\n前端页面访问服务器时,获取服务器返回的http请求回来的header信息,如下图:\n![](/assets/img/header.png)\n获取Response Header的方法:\n<!-- more -->\n1.js-ajax方法获取:\n```\nfunction ajax(){\n    var xhr = null;\n    var url = window.location.href;\n    if(window.xhrRequest){\n      xhr = new window.xhrRequest();\n    }else{ // ie\n      xhr = new ActiveObject(\"Microsoft\")\n    }\n    // 通过get的方式请求当前文件\n    xhr.open(\"get\",url,false);  //同步\n    //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。\n    //xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n    //xhr.send(\"fname=Henry&lname=Ford\");\n    xhr.send(null);\n    // 监听请求状态变化 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：\n    xhr.onreadystatechange = function(){\n        //if (xhr.readyState==4 && xhr.status==200)\n        if(xhr.readyState===2){\n            var time = xhr.getResponseHeader(\"Date\");\n            var curDate = new Date(time);\n        }\n    }\n    if (xhr.status === 200) {\n        var time = xhr.getResponseHeader(\"Date\");\n        curDate = new Date(time);\n    }\n\n    //其他ajax相关\n    //xhr.responseText\t获得字符串形式的响应数据。\n    //xhr.responseXML\t获得 XML 形式的响应数据。\n  }\n```\n2.jquery-ajax方法获取:\n```\n$.ajax({\n    type: 'HEAD', // 获取头信息，type=HEAD即可\n    url : window.location.href,\n    complete: function(xhr,data){// 获取相关Http Response header\n        var wpoInfo = {\n            \"date\" : xhr.getResponseHeader('Date'),// 服务器端时间\n            \"contentEncoding\" : xhr.getResponseHeader('Content-Encoding'),// 如果开启了gzip，会返回这个东西\n            \"connection\" : xhr.getResponseHeader('Connection'),// keep-alive ？ close？\n            \"contentLength\" : xhr.getResponseHeader('Content-Length'),// 响应长度\n            \"server\" : xhr.getResponseHeader('Server'),// 服务器类型，apache？lighttpd？\n            \"vary\" : xhr.getResponseHeader('Vary'),\n            \"transferEncoding\" : xhr.getResponseHeader('Transfer-Encoding'),\n            \"contentType\" : xhr.getResponseHeader('Content-Type'),// text/html ? text/xml?\n            \"cacheControl\" : xhr.getResponseHeader('Cache-Control'),\n            \"exprires\" : xhr.getResponseHeader('Exprires'),// 生命周期？\n            \"lastModified\" : xhr.getResponseHeader('Last-Modified')\n        };\n        var curDate = new Date(wpoInfo.date);\n    }\n});\n```\n!!!\n注意:通过header获取的时间是格林威治时间,北京时间与格林威治时间或UTC时间相差8个时区，北京、上海、重庆位于东8区，\n所以北京时间过了8小时,获取之后记得换算成北京时间!!!\n","slug":"http-headers","published":1,"date":"2018-11-19T09:04:19.959Z","updated":"2018-11-19T09:04:19.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bwm0003natf95f8w7qk","content":"<p>前端页面访问服务器时,获取服务器返回的http请求回来的header信息,如下图:<br><img src=\"/assets/img/header.png\" alt=\"\"><br>获取Response Header的方法:<br><a id=\"more\"></a><br>1.js-ajax方法获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ajax()&#123;</span><br><span class=\"line\">    var xhr = null;</span><br><span class=\"line\">    var url = window.location.href;</span><br><span class=\"line\">    if(window.xhrRequest)&#123;</span><br><span class=\"line\">      xhr = new window.xhrRequest();</span><br><span class=\"line\">    &#125;else&#123; // ie</span><br><span class=\"line\">      xhr = new ActiveObject(&quot;Microsoft&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 通过get的方式请求当前文件</span><br><span class=\"line\">    xhr.open(&quot;get&quot;,url,false);  //同步</span><br><span class=\"line\">    //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。</span><br><span class=\"line\">    //xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">    //xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br><span class=\"line\">    xhr.send(null);</span><br><span class=\"line\">    // 监听请求状态变化 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：</span><br><span class=\"line\">    xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">        //if (xhr.readyState==4 &amp;&amp; xhr.status==200)</span><br><span class=\"line\">        if(xhr.readyState===2)&#123;</span><br><span class=\"line\">            var time = xhr.getResponseHeader(&quot;Date&quot;);</span><br><span class=\"line\">            var curDate = new Date(time);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (xhr.status === 200) &#123;</span><br><span class=\"line\">        var time = xhr.getResponseHeader(&quot;Date&quot;);</span><br><span class=\"line\">        curDate = new Date(time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //其他ajax相关</span><br><span class=\"line\">    //xhr.responseText\t获得字符串形式的响应数据。</span><br><span class=\"line\">    //xhr.responseXML\t获得 XML 形式的响应数据。</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.jquery-ajax方法获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &apos;HEAD&apos;, // 获取头信息，type=HEAD即可</span><br><span class=\"line\">    url : window.location.href,</span><br><span class=\"line\">    complete: function(xhr,data)&#123;// 获取相关Http Response header</span><br><span class=\"line\">        var wpoInfo = &#123;</span><br><span class=\"line\">            &quot;date&quot; : xhr.getResponseHeader(&apos;Date&apos;),// 服务器端时间</span><br><span class=\"line\">            &quot;contentEncoding&quot; : xhr.getResponseHeader(&apos;Content-Encoding&apos;),// 如果开启了gzip，会返回这个东西</span><br><span class=\"line\">            &quot;connection&quot; : xhr.getResponseHeader(&apos;Connection&apos;),// keep-alive ？ close？</span><br><span class=\"line\">            &quot;contentLength&quot; : xhr.getResponseHeader(&apos;Content-Length&apos;),// 响应长度</span><br><span class=\"line\">            &quot;server&quot; : xhr.getResponseHeader(&apos;Server&apos;),// 服务器类型，apache？lighttpd？</span><br><span class=\"line\">            &quot;vary&quot; : xhr.getResponseHeader(&apos;Vary&apos;),</span><br><span class=\"line\">            &quot;transferEncoding&quot; : xhr.getResponseHeader(&apos;Transfer-Encoding&apos;),</span><br><span class=\"line\">            &quot;contentType&quot; : xhr.getResponseHeader(&apos;Content-Type&apos;),// text/html ? text/xml?</span><br><span class=\"line\">            &quot;cacheControl&quot; : xhr.getResponseHeader(&apos;Cache-Control&apos;),</span><br><span class=\"line\">            &quot;exprires&quot; : xhr.getResponseHeader(&apos;Exprires&apos;),// 生命周期？</span><br><span class=\"line\">            &quot;lastModified&quot; : xhr.getResponseHeader(&apos;Last-Modified&apos;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var curDate = new Date(wpoInfo.date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>!!!<br>注意:通过header获取的时间是格林威治时间,北京时间与格林威治时间或UTC时间相差8个时区，北京、上海、重庆位于东8区，<br>所以北京时间过了8小时,获取之后记得换算成北京时间!!!</p>\n","site":{"data":{}},"excerpt":"<p>前端页面访问服务器时,获取服务器返回的http请求回来的header信息,如下图:<br><img src=\"/assets/img/header.png\" alt=\"\"><br>获取Response Header的方法:<br>","more":"<br>1.js-ajax方法获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ajax()&#123;</span><br><span class=\"line\">    var xhr = null;</span><br><span class=\"line\">    var url = window.location.href;</span><br><span class=\"line\">    if(window.xhrRequest)&#123;</span><br><span class=\"line\">      xhr = new window.xhrRequest();</span><br><span class=\"line\">    &#125;else&#123; // ie</span><br><span class=\"line\">      xhr = new ActiveObject(&quot;Microsoft&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 通过get的方式请求当前文件</span><br><span class=\"line\">    xhr.open(&quot;get&quot;,url,false);  //同步</span><br><span class=\"line\">    //不推荐使用 async=false，但是对于一些小型的请求，也是可以的。</span><br><span class=\"line\">    //xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">    //xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br><span class=\"line\">    xhr.send(null);</span><br><span class=\"line\">    // 监听请求状态变化 当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：</span><br><span class=\"line\">    xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">        //if (xhr.readyState==4 &amp;&amp; xhr.status==200)</span><br><span class=\"line\">        if(xhr.readyState===2)&#123;</span><br><span class=\"line\">            var time = xhr.getResponseHeader(&quot;Date&quot;);</span><br><span class=\"line\">            var curDate = new Date(time);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (xhr.status === 200) &#123;</span><br><span class=\"line\">        var time = xhr.getResponseHeader(&quot;Date&quot;);</span><br><span class=\"line\">        curDate = new Date(time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //其他ajax相关</span><br><span class=\"line\">    //xhr.responseText\t获得字符串形式的响应数据。</span><br><span class=\"line\">    //xhr.responseXML\t获得 XML 形式的响应数据。</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.jquery-ajax方法获取:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &apos;HEAD&apos;, // 获取头信息，type=HEAD即可</span><br><span class=\"line\">    url : window.location.href,</span><br><span class=\"line\">    complete: function(xhr,data)&#123;// 获取相关Http Response header</span><br><span class=\"line\">        var wpoInfo = &#123;</span><br><span class=\"line\">            &quot;date&quot; : xhr.getResponseHeader(&apos;Date&apos;),// 服务器端时间</span><br><span class=\"line\">            &quot;contentEncoding&quot; : xhr.getResponseHeader(&apos;Content-Encoding&apos;),// 如果开启了gzip，会返回这个东西</span><br><span class=\"line\">            &quot;connection&quot; : xhr.getResponseHeader(&apos;Connection&apos;),// keep-alive ？ close？</span><br><span class=\"line\">            &quot;contentLength&quot; : xhr.getResponseHeader(&apos;Content-Length&apos;),// 响应长度</span><br><span class=\"line\">            &quot;server&quot; : xhr.getResponseHeader(&apos;Server&apos;),// 服务器类型，apache？lighttpd？</span><br><span class=\"line\">            &quot;vary&quot; : xhr.getResponseHeader(&apos;Vary&apos;),</span><br><span class=\"line\">            &quot;transferEncoding&quot; : xhr.getResponseHeader(&apos;Transfer-Encoding&apos;),</span><br><span class=\"line\">            &quot;contentType&quot; : xhr.getResponseHeader(&apos;Content-Type&apos;),// text/html ? text/xml?</span><br><span class=\"line\">            &quot;cacheControl&quot; : xhr.getResponseHeader(&apos;Cache-Control&apos;),</span><br><span class=\"line\">            &quot;exprires&quot; : xhr.getResponseHeader(&apos;Exprires&apos;),// 生命周期？</span><br><span class=\"line\">            &quot;lastModified&quot; : xhr.getResponseHeader(&apos;Last-Modified&apos;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        var curDate = new Date(wpoInfo.date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>!!!<br>注意:通过header获取的时间是格林威治时间,北京时间与格林威治时间或UTC时间相差8个时区，北京、上海、重庆位于东8区，<br>所以北京时间过了8小时,获取之后记得换算成北京时间!!!</p>"},{"title":"Bootstrap-Metro后台管理模板","_content":"![](/assets/img/bootstrapMetro.png)\n---\n[【查看演示】](https://holdcast.github.io/metro/)[【源码下载】](https://github.com/HoldCast/metro)[【官方文档】](http://www.bootcss.com/p/metro-ui-css/index.html)","source":"_posts/bootstrap-metro.md","raw":"title: Bootstrap-Metro后台管理模板\ntags:\n  - bootstrap\n  - 响应式\n  - metro\n---\n![](/assets/img/bootstrapMetro.png)\n---\n[【查看演示】](https://holdcast.github.io/metro/)[【源码下载】](https://github.com/HoldCast/metro)[【官方文档】](http://www.bootcss.com/p/metro-ui-css/index.html)","slug":"bootstrap-metro","published":1,"date":"2018-11-19T09:04:19.959Z","updated":"2018-11-19T09:04:19.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bwn0004natfdr6te2de","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/assets/img/bootstrapMetro.png\" alt=\"\"></h2><p><a href=\"https://holdcast.github.io/metro/\">【查看演示】</a><a href=\"https://github.com/HoldCast/metro\" target=\"_blank\" rel=\"noopener\">【源码下载】</a><a href=\"http://www.bootcss.com/p/metro-ui-css/index.html\" target=\"_blank\" rel=\"noopener\">【官方文档】</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/assets/img/bootstrapMetro.png\" alt=\"\"></h2><p><a href=\"https://holdcast.github.io/metro/\">【查看演示】</a><a href=\"https://github.com/HoldCast/metro\" target=\"_blank\" rel=\"noopener\">【源码下载】</a><a href=\"http://www.bootcss.com/p/metro-ui-css/index.html\" target=\"_blank\" rel=\"noopener\">【官方文档】</a></p>\n"},{"title":"http请求返回状态码解析","_content":"### 一些常见的状态码为：\n  - 200：服务器响应正常。\n  - 304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。\n  - 400：无法找到请求的资源。\n  - 401：访问资源的权限不够。\n  - 403：没有权限访问资源。\n  - 404：需要访问的资源不存在。\n  - 405：需要访问的资源被禁止。\n  - 407：访问的资源需要代理身份验证。\n  - 414：请求的URL太长。\n  - 500：服务器内部错误。\n\n### 下面提供 HTTP 状态码的完整列表：\n\n<!-- more -->\n\n#### 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\n100（继续）\t请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\n101（切换协议）\t请求者已要求服务器切换协议，服务器已确认并准备切换。\n\n#### 2xx （成功）表示成功处理了请求的状态码。\n200（成功）\t服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。\n201（已创建）\t请求成功并且服务器创建了新的资源。\n202（已接受）\t服务器已接受请求，但尚未处理。\n203（非授权信息）\t服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204（无内容）\t服务器成功处理了请求，但没有返回任何内容。\n205（重置内容）\t服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。\n206（部分内容）\t服务器成功处理了部分 GET 请求。\n\n#### 3xx （重定向）要完成请求，需要进一步操作。\n##### 通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。\n300（多种选择）\t针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。\n301（永久移动）\t请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。\n302（临时移动）\t服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。\n303（查看其他位置）\t请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。\n304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。\n305（使用代理）\t请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。\n307（临时重定向）\t服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=answer.py?answer=>301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。\n\n#### 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\n400（错误请求）\t服务器不理解请求的语法。\n401（未授权）\t请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。\n403（禁止）\t服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。\n404（未找到） 服务器找不到请求的网页。\n405（方法禁用）\t禁用请求中指定的方法。\n406（不接受）\t无法使用请求的内容特性响应请求的网页。\n407（需要代理授权）\t此状态码与 <a href=answer.py?answer=35128>401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。\n408（请求超时）\t服务器等候请求时发生超时。\n409（冲突）\t服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。\n410（已删除）\t如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。\n411（需要有效长度）\t服务器不接受不含有效内容长度标头字段的请求。\n412（未满足前提条件）\t服务器未满足请求者在请求中设置的其中一个前提条件。\n413（请求实体过大）\t服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\n414（请求的 URI 过长）\t请求的 URI（通常为网址）过长，服务器无法处理。\n415（不支持的媒体类型）\t请求的格式不受请求页面的支持。\n416（请求范围不符合要求）\t如果页面无法提供请求的范围，则服务器会返回此状态码。\n417（未满足期望值）\t服务器未满足\"期望\"请求标头字段的要求。\n\n#### 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\n500（服务器内部错误）\t服务器遇到错误，无法完成请求。\n501（尚未实施）\t服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。\n502（错误网关）\t服务器作为网关或代理，从上游服务器收到无效响应。\n503（服务不可用）\t服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。\n504（网关超时）\t服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n505（HTTP 版本不受支持）\t服务器不支持请求中所用的 HTTP 协议版本。\n\n转自http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html","source":"_posts/http-status.md","raw":"title: http请求返回状态码解析\ntags:\n - http\n - 状态码\n---\n### 一些常见的状态码为：\n  - 200：服务器响应正常。\n  - 304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。\n  - 400：无法找到请求的资源。\n  - 401：访问资源的权限不够。\n  - 403：没有权限访问资源。\n  - 404：需要访问的资源不存在。\n  - 405：需要访问的资源被禁止。\n  - 407：访问的资源需要代理身份验证。\n  - 414：请求的URL太长。\n  - 500：服务器内部错误。\n\n### 下面提供 HTTP 状态码的完整列表：\n\n<!-- more -->\n\n#### 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\n100（继续）\t请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\n101（切换协议）\t请求者已要求服务器切换协议，服务器已确认并准备切换。\n\n#### 2xx （成功）表示成功处理了请求的状态码。\n200（成功）\t服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。\n201（已创建）\t请求成功并且服务器创建了新的资源。\n202（已接受）\t服务器已接受请求，但尚未处理。\n203（非授权信息）\t服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204（无内容）\t服务器成功处理了请求，但没有返回任何内容。\n205（重置内容）\t服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。\n206（部分内容）\t服务器成功处理了部分 GET 请求。\n\n#### 3xx （重定向）要完成请求，需要进一步操作。\n##### 通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。\n300（多种选择）\t针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。\n301（永久移动）\t请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。\n302（临时移动）\t服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。\n303（查看其他位置）\t请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。\n304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。\n305（使用代理）\t请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。\n307（临时重定向）\t服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=answer.py?answer=>301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。\n\n#### 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\n400（错误请求）\t服务器不理解请求的语法。\n401（未授权）\t请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。\n403（禁止）\t服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。\n404（未找到） 服务器找不到请求的网页。\n405（方法禁用）\t禁用请求中指定的方法。\n406（不接受）\t无法使用请求的内容特性响应请求的网页。\n407（需要代理授权）\t此状态码与 <a href=answer.py?answer=35128>401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。\n408（请求超时）\t服务器等候请求时发生超时。\n409（冲突）\t服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。\n410（已删除）\t如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。\n411（需要有效长度）\t服务器不接受不含有效内容长度标头字段的请求。\n412（未满足前提条件）\t服务器未满足请求者在请求中设置的其中一个前提条件。\n413（请求实体过大）\t服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\n414（请求的 URI 过长）\t请求的 URI（通常为网址）过长，服务器无法处理。\n415（不支持的媒体类型）\t请求的格式不受请求页面的支持。\n416（请求范围不符合要求）\t如果页面无法提供请求的范围，则服务器会返回此状态码。\n417（未满足期望值）\t服务器未满足\"期望\"请求标头字段的要求。\n\n#### 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\n500（服务器内部错误）\t服务器遇到错误，无法完成请求。\n501（尚未实施）\t服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。\n502（错误网关）\t服务器作为网关或代理，从上游服务器收到无效响应。\n503（服务不可用）\t服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。\n504（网关超时）\t服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n505（HTTP 版本不受支持）\t服务器不支持请求中所用的 HTTP 协议版本。\n\n转自http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html","slug":"http-status","published":1,"date":"2018-11-19T09:04:19.959Z","updated":"2018-11-19T09:04:19.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bwo0005natfig6ob6jx","content":"<h3 id=\"一些常见的状态码为：\"><a href=\"#一些常见的状态码为：\" class=\"headerlink\" title=\"一些常见的状态码为：\"></a>一些常见的状态码为：</h3><ul>\n<li>200：服务器响应正常。</li>\n<li>304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。</li>\n<li>400：无法找到请求的资源。</li>\n<li>401：访问资源的权限不够。</li>\n<li>403：没有权限访问资源。</li>\n<li>404：需要访问的资源不存在。</li>\n<li>405：需要访问的资源被禁止。</li>\n<li>407：访问的资源需要代理身份验证。</li>\n<li>414：请求的URL太长。</li>\n<li>500：服务器内部错误。</li>\n</ul>\n<h3 id=\"下面提供-HTTP-状态码的完整列表：\"><a href=\"#下面提供-HTTP-状态码的完整列表：\" class=\"headerlink\" title=\"下面提供 HTTP 状态码的完整列表：\"></a>下面提供 HTTP 状态码的完整列表：</h3><a id=\"more\"></a>\n<h4 id=\"1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\"><a href=\"#1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\" class=\"headerlink\" title=\"1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\"></a>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。</h4><p>100（继续）    请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101（切换协议）    请求者已要求服务器切换协议，服务器已确认并准备切换。</p>\n<h4 id=\"2xx-（成功）表示成功处理了请求的状态码。\"><a href=\"#2xx-（成功）表示成功处理了请求的状态码。\" class=\"headerlink\" title=\"2xx （成功）表示成功处理了请求的状态码。\"></a>2xx （成功）表示成功处理了请求的状态码。</h4><p>200（成功）    服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。<br>201（已创建）    请求成功并且服务器创建了新的资源。<br>202（已接受）    服务器已接受请求，但尚未处理。<br>203（非授权信息）    服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204（无内容）    服务器成功处理了请求，但没有返回任何内容。<br>205（重置内容）    服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。<br>206（部分内容）    服务器成功处理了部分 GET 请求。</p>\n<h4 id=\"3xx-（重定向）要完成请求，需要进一步操作。\"><a href=\"#3xx-（重定向）要完成请求，需要进一步操作。\" class=\"headerlink\" title=\"3xx （重定向）要完成请求，需要进一步操作。\"></a>3xx （重定向）要完成请求，需要进一步操作。</h4><h5 id=\"通常，这些状态码用来重定向。Google-建议您在每次请求中使用重定向不要超过-5-次。您可以使用网站管理员工具查看一下-Googlebot-在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致-Googlebot-无法抓取的网址。\"><a href=\"#通常，这些状态码用来重定向。Google-建议您在每次请求中使用重定向不要超过-5-次。您可以使用网站管理员工具查看一下-Googlebot-在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致-Googlebot-无法抓取的网址。\" class=\"headerlink\" title=\"通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。\"></a>通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。</h5><p>300（多种选择）    针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301（永久移动）    请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。<br>302（临时移动）    服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。<br>303（查看其他位置）    请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。<br>304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。<br>305（使用代理）    请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。<br>307（临时重定向）    服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=\"answer.py?answer=\">301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>\n<h4 id=\"4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\"><a href=\"#4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\" class=\"headerlink\" title=\"4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\"></a>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。</h4><p>400（错误请求）    服务器不理解请求的语法。<br>401（未授权）    请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。<br>403（禁止）    服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。<br>404（未找到） 服务器找不到请求的网页。<br>405（方法禁用）    禁用请求中指定的方法。<br>406（不接受）    无法使用请求的内容特性响应请求的网页。<br>407（需要代理授权）    此状态码与 <a href=\"answer.py?answer=35128\">401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。<br>408（请求超时）    服务器等候请求时发生超时。<br>409（冲突）    服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。<br>410（已删除）    如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。<br>411（需要有效长度）    服务器不接受不含有效内容长度标头字段的请求。<br>412（未满足前提条件）    服务器未满足请求者在请求中设置的其中一个前提条件。<br>413（请求实体过大）    服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414（请求的 URI 过长）    请求的 URI（通常为网址）过长，服务器无法处理。<br>415（不支持的媒体类型）    请求的格式不受请求页面的支持。<br>416（请求范围不符合要求）    如果页面无法提供请求的范围，则服务器会返回此状态码。<br>417（未满足期望值）    服务器未满足”期望”请求标头字段的要求。</p>\n<h4 id=\"5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\"><a href=\"#5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\" class=\"headerlink\" title=\"5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\"></a>5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</h4><p>500（服务器内部错误）    服务器遇到错误，无法完成请求。<br>501（尚未实施）    服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br>502（错误网关）    服务器作为网关或代理，从上游服务器收到无效响应。<br>503（服务不可用）    服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br>504（网关超时）    服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505（HTTP 版本不受支持）    服务器不支持请求中所用的 HTTP 协议版本。</p>\n<p>转自<a href=\"http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html\" target=\"_blank\" rel=\"noopener\">http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一些常见的状态码为：\"><a href=\"#一些常见的状态码为：\" class=\"headerlink\" title=\"一些常见的状态码为：\"></a>一些常见的状态码为：</h3><ul>\n<li>200：服务器响应正常。</li>\n<li>304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。</li>\n<li>400：无法找到请求的资源。</li>\n<li>401：访问资源的权限不够。</li>\n<li>403：没有权限访问资源。</li>\n<li>404：需要访问的资源不存在。</li>\n<li>405：需要访问的资源被禁止。</li>\n<li>407：访问的资源需要代理身份验证。</li>\n<li>414：请求的URL太长。</li>\n<li>500：服务器内部错误。</li>\n</ul>\n<h3 id=\"下面提供-HTTP-状态码的完整列表：\"><a href=\"#下面提供-HTTP-状态码的完整列表：\" class=\"headerlink\" title=\"下面提供 HTTP 状态码的完整列表：\"></a>下面提供 HTTP 状态码的完整列表：</h3>","more":"<h4 id=\"1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\"><a href=\"#1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\" class=\"headerlink\" title=\"1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。\"></a>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。</h4><p>100（继续）    请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101（切换协议）    请求者已要求服务器切换协议，服务器已确认并准备切换。</p>\n<h4 id=\"2xx-（成功）表示成功处理了请求的状态码。\"><a href=\"#2xx-（成功）表示成功处理了请求的状态码。\" class=\"headerlink\" title=\"2xx （成功）表示成功处理了请求的状态码。\"></a>2xx （成功）表示成功处理了请求的状态码。</h4><p>200（成功）    服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。<br>201（已创建）    请求成功并且服务器创建了新的资源。<br>202（已接受）    服务器已接受请求，但尚未处理。<br>203（非授权信息）    服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204（无内容）    服务器成功处理了请求，但没有返回任何内容。<br>205（重置内容）    服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。<br>206（部分内容）    服务器成功处理了部分 GET 请求。</p>\n<h4 id=\"3xx-（重定向）要完成请求，需要进一步操作。\"><a href=\"#3xx-（重定向）要完成请求，需要进一步操作。\" class=\"headerlink\" title=\"3xx （重定向）要完成请求，需要进一步操作。\"></a>3xx （重定向）要完成请求，需要进一步操作。</h4><h5 id=\"通常，这些状态码用来重定向。Google-建议您在每次请求中使用重定向不要超过-5-次。您可以使用网站管理员工具查看一下-Googlebot-在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致-Googlebot-无法抓取的网址。\"><a href=\"#通常，这些状态码用来重定向。Google-建议您在每次请求中使用重定向不要超过-5-次。您可以使用网站管理员工具查看一下-Googlebot-在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致-Googlebot-无法抓取的网址。\" class=\"headerlink\" title=\"通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。\"></a>通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。</h5><p>300（多种选择）    针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301（永久移动）    请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。<br>302（临时移动）    服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。<br>303（查看其他位置）    请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。<br>304（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。<br>305（使用代理）    请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。<br>307（临时重定向）    服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=\"answer.py?answer=\">301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</p>\n<h4 id=\"4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\"><a href=\"#4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\" class=\"headerlink\" title=\"4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。\"></a>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。</h4><p>400（错误请求）    服务器不理解请求的语法。<br>401（未授权）    请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。<br>403（禁止）    服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。<br>404（未找到） 服务器找不到请求的网页。<br>405（方法禁用）    禁用请求中指定的方法。<br>406（不接受）    无法使用请求的内容特性响应请求的网页。<br>407（需要代理授权）    此状态码与 <a href=\"answer.py?answer=35128\">401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。<br>408（请求超时）    服务器等候请求时发生超时。<br>409（冲突）    服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。<br>410（已删除）    如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。<br>411（需要有效长度）    服务器不接受不含有效内容长度标头字段的请求。<br>412（未满足前提条件）    服务器未满足请求者在请求中设置的其中一个前提条件。<br>413（请求实体过大）    服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414（请求的 URI 过长）    请求的 URI（通常为网址）过长，服务器无法处理。<br>415（不支持的媒体类型）    请求的格式不受请求页面的支持。<br>416（请求范围不符合要求）    如果页面无法提供请求的范围，则服务器会返回此状态码。<br>417（未满足期望值）    服务器未满足”期望”请求标头字段的要求。</p>\n<h4 id=\"5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\"><a href=\"#5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\" class=\"headerlink\" title=\"5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\"></a>5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</h4><p>500（服务器内部错误）    服务器遇到错误，无法完成请求。<br>501（尚未实施）    服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br>502（错误网关）    服务器作为网关或代理，从上游服务器收到无效响应。<br>503（服务不可用）    服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br>504（网关超时）    服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505（HTTP 版本不受支持）    服务器不支持请求中所用的 HTTP 协议版本。</p>\n<p>转自<a href=\"http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html\" target=\"_blank\" rel=\"noopener\">http://www.gosoa.com.cn/Article/2009-11/2009-11-01-154.html</a></p>"},{"title":"HTTP协议 - HyperText Transfer Protocol，超文本传输协议","_content":">因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### 工作原理\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\nWeb服务器有：Apache服务器，IIS服务器（Internet Information Services）等。\nWeb服务器根据接收到的请求后，向客户端发送响应信息。\nHTTP默认端口号为80，但是你也可以改为8080或者其他端口。\n#### HTTP - 三点注意事项：\n- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)\n- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n  HTTP协议通信流程：\n![](/assets/img/http-lc.png)\n(Common Gateway Interface，简称CGI)\n\n<!-- more -->\n### 请求方法\n根据HTTP标准，HTTP请求可以使用多种请求方法。\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n1.GET\t请求指定的页面信息，并返回实体主体。\n2.HEAD\t类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3.POST\t向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4.PUT\t从客户端向服务器传送的数据取代指定的文档的内容。\n5.DELETE\t请求服务器删除指定的页面。\n6.CONNECT\tHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7.OPTIONS\t允许客户端查看服务器的性能。\n8.TRACE\t回显服务器收到的请求，主要用于测试或诊断。\n\n### 响应头信息\n- Allow 服务器支持哪些请求方法（如GET、POST等）。\n- Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\n- Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\n- Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\n- Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\n- Expires 应该在什么时候认为文档已经过期，从而不再缓存它？\n- Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\n- Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\n- Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=<span>http://host/path</span>\")让浏览器读取指定的页面。\n  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"</pre>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。\n  注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。\n  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\n- Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\n- Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\n- WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。\n  注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n","source":"_posts/http.md","raw":"title: HTTP协议 - HyperText Transfer Protocol，超文本传输协议\ntags:\n    - http\n---\n>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### 工作原理\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\nWeb服务器有：Apache服务器，IIS服务器（Internet Information Services）等。\nWeb服务器根据接收到的请求后，向客户端发送响应信息。\nHTTP默认端口号为80，但是你也可以改为8080或者其他端口。\n#### HTTP - 三点注意事项：\n- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)\n- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n  HTTP协议通信流程：\n![](/assets/img/http-lc.png)\n(Common Gateway Interface，简称CGI)\n\n<!-- more -->\n### 请求方法\n根据HTTP标准，HTTP请求可以使用多种请求方法。\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n1.GET\t请求指定的页面信息，并返回实体主体。\n2.HEAD\t类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3.POST\t向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4.PUT\t从客户端向服务器传送的数据取代指定的文档的内容。\n5.DELETE\t请求服务器删除指定的页面。\n6.CONNECT\tHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7.OPTIONS\t允许客户端查看服务器的性能。\n8.TRACE\t回显服务器收到的请求，主要用于测试或诊断。\n\n### 响应头信息\n- Allow 服务器支持哪些请求方法（如GET、POST等）。\n- Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\n- Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\n- Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\n- Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\n- Expires 应该在什么时候认为文档已经过期，从而不再缓存它？\n- Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\n- Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\n- Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=<span>http://host/path</span>\")让浏览器读取指定的页面。\n  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"</pre>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。\n  注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。\n  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\n- Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\n- Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\n- WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。\n  注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n","slug":"http","published":1,"date":"2018-11-19T09:04:19.960Z","updated":"2018-11-19T09:04:19.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bwp0007natfgdcozam6","content":"<blockquote>\n<p>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n</blockquote>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>\n<h4 id=\"HTTP-三点注意事项：\"><a href=\"#HTTP-三点注意事项：\" class=\"headerlink\" title=\"HTTP - 三点注意事项：\"></a>HTTP - 三点注意事项：</h4><ul>\n<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>\n<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)</li>\n<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>HTTP协议通信流程：<br><img src=\"/assets/img/http-lc.png\" alt=\"\"><br>(Common Gateway Interface，简称CGI)</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>1.GET    请求指定的页面信息，并返回实体主体。<br>2.HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3.POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>4.PUT    从客户端向服务器传送的数据取代指定的文档的内容。<br>5.DELETE    请求服务器删除指定的页面。<br>6.CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>7.OPTIONS    允许客户端查看服务器的性能。<br>8.TRACE    回显服务器收到的请求，主要用于测试或诊断。</p>\n<h3 id=\"响应头信息\"><a href=\"#响应头信息\" class=\"headerlink\" title=\"响应头信息\"></a>响应头信息</h3><ul>\n<li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li>\n<li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li>\n<li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>\n<li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</li>\n<li>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>\n<li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li>\n<li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li>\n<li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li>\n<li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<span><a href=\"http://host/path\" target=\"_blank\" rel=\"noopener\">http://host/path</a></span>“)让浏览器读取指定的页面。<br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;\" target=\"_blank\" rel=\"noopener\">http://host/path&quot;</a>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。<br>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。<br>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li>\n<li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li>\n<li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</li>\n<li>WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n</blockquote>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>\n<h4 id=\"HTTP-三点注意事项：\"><a href=\"#HTTP-三点注意事项：\" class=\"headerlink\" title=\"HTTP - 三点注意事项：\"></a>HTTP - 三点注意事项：</h4><ul>\n<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>\n<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)</li>\n<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>HTTP协议通信流程：<br><img src=\"/assets/img/http-lc.png\" alt=\"\"><br>(Common Gateway Interface，简称CGI)</li>\n</ul>","more":"<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>1.GET    请求指定的页面信息，并返回实体主体。<br>2.HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3.POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>4.PUT    从客户端向服务器传送的数据取代指定的文档的内容。<br>5.DELETE    请求服务器删除指定的页面。<br>6.CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>7.OPTIONS    允许客户端查看服务器的性能。<br>8.TRACE    回显服务器收到的请求，主要用于测试或诊断。</p>\n<h3 id=\"响应头信息\"><a href=\"#响应头信息\" class=\"headerlink\" title=\"响应头信息\"></a>响应头信息</h3><ul>\n<li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li>\n<li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li>\n<li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>\n<li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</li>\n<li>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>\n<li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li>\n<li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li>\n<li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li>\n<li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<span><a href=\"http://host/path\" target=\"_blank\" rel=\"noopener\">http://host/path</a></span>“)让浏览器读取指定的页面。<br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;\" target=\"_blank\" rel=\"noopener\">http://host/path&quot;</a>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。<br>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。<br>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li>\n<li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li>\n<li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</li>\n<li>WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</li>\n</ul>"},{"title":"响应式布局和移动端适配方案","_content":"前端响应式开发包括两个方向,web(pc)端的页面显示和移动端的页面显示,一般页面内容比较少,布局相对简单的页面可以直接采用媒体查询的方式来实现响应式;\n移动端和PC端需要展示不同的页面样式风格的页面,可以采用pc端响应式,移动端自动适配的方案.\n1.响应式布局 2.移动端适配-rem\n\n>不同的需求,采用不同的方案\n\n### 一.响应式布局\n1.设计思路：\n使用CSS3中媒体查询的大致思路就是判断网页在不同设备中所处的宽度范围，这样的范围可能有三种（PC、平板、手机），也可能有四种（PC、平板、中大屏手机、小屏手机），当然也可能只需要两种（平板、手机，PC端单独开发一版时可不作为CSS3媒体查询的使用对象），并为各种宽度范围情况下的所需页面元素套用不同的CSS样式，从而适配各种设备。\n\n<!-- more -->\n\n2.响应式网页开发中的宽度问题：\n在实际开发中，通常需要设置响应式网页宽度的最大值，一旦忽略最大宽度，臃肿或零散的网页布局都会造成视觉洪灾，也就是我们常说的看起来很low。\n目前最为常见的宽度基本上都是：大于或等于960px的PC端（1920px、1600px、1440px、1280px、1140px、960px）、960px至640px之间的平板端（768px、640px）以及640px以下的手机端（480px、320px），以上宽度存在已久，且显示设备中的网页宽度会长期处于这样的状态下，在响应式网页宽度设计上，基本从这几个尺寸考虑就已经足够。\n\n3.初始化设置：\n在HTML文件中，网页顶部<head></head>标签中插入一句话：\n```\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n这句话在于对响应式网页做一个初始化设置，主要包括：\nname=\"viewport\"：标记显示设备为视口；\nwidth = device-width：宽度等于当前设备的宽度；\ninitial-scale：初始的缩放比例（默认设置为1.0）；\nminimum-scale：允许用户缩放到的最小比例（默认设置为1.0）；\nmaximum-scale：允许用户缩放到的最大比例（默认设置为1.0）；\nuser-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）。\n\n4.解决IE浏览器的兼容性问题：\n因为IE浏览器(IE8)不支持HTML5和CSS3中的media，所以要加载用于解决IE浏览器兼容性问题的JS文件：\n```\n    <!--[if lt IE 9]>\n    <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n    <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n    <![endif]-->\n```\n两个<script></script>标签中的src属性所指向的文件链接地址为固定地址中的文件，直接异地引用就好，不用下载到本地引用。\n\n5.设置IE的渲染方式为最高：\n现在有很多人的IE浏览器都升级到IE9以上，这个时候会有很多诡异的事情发生，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8，为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新：\n```\n<meta http-equiv=\"X-UA-Compatible\"content=\"IE=edge\">\n```\n当然还有一个更给力的写法：\n```\n<meta http-equiv=\"X-UA-Compatible\"content=\"IE=Edge，chrome=1\">\n```\n这段代码后面加了一个chrome=1，这是由于Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果用户电脑安装这个chrome插件，就可让电脑内的IE浏览器规避版本因素，使用Webkit引擎及V8引擎进行排版及运算。当然如果用户没装这个插件，这段代码就会让IE浏览器以最高的文档模式展现效果。\n\n6.CSS3 media 媒体查询的写法：\n```\n@media screen and (max-width: 960px){body{background:#000;}}\n```\n这是一个media的标准写法，在CSS文件中，意为：当页面小于960px时执行以下CSS代码，具体内容暂不用管。\n对于上述代码中的screen，意为在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。目前很多网站都会直接省略screen,从而不需要考虑用户打印网页的需求，所以又有这种写法：\n```\n@media (max-width: 960px){\n    body{background:#000;}\n}\n```\n本着思维严谨的原则，一般不采用这种写法。\n\n7.CSS3媒体查询主体代码组合：\n在响应式网页布局中需要持续运用媒体查询代码组合，主要作用在于判断所适配屏幕的宽度，并根据各种宽度条件套用不同的CSS样式。\n- 如当屏幕宽度等于960px时，将网页背景色变为红色：\n```\n@media screen and (max-device-width:960px){\n    body{background:red;}\n}\n```\n\n- 如当屏幕宽度最大为960px（小于960px）时，将网页背景色变为黑色：\n```\n@media screen and (max-width: 960px){\n    body{background:#000;}\n}\n```\n\n- 如当屏幕宽度最小为960px（大于960px）时，将网页背景色变为桔色：\n```\n@media screen and (min-width:960px){\n    body{background:orange;}\n}\n```\n\n- 更为常见的是混合使用，如当屏幕宽度介于960px和1200px之间时，将网页背景色变为黄色：\n```\n@media screen and (min-width:960px) and(max-width:1200px){\n    body{background:yellow;}\n}\n```\n\n8.media媒体查询所有参数汇总：\n媒体查询器中还包含并不常用的相关功能，悉如示下：\nwidth:浏览器可视宽度，\nheight:浏览器可视高度，\ndevice-width:设备屏幕的宽度，\ndevice-height:设备屏幕的高度，\norientation:检测设备目前处于横向还是纵向状态，\naspect-ratio:检测浏览器可视宽度和高度的比例(例如：aspect-ratio:16/9)，\ndevice-aspect-ratio:检测设备的宽度和高度的比例，\ncolor:检测颜色的位数（例如：min-color:32就会检测设备是否拥有32位颜色），\ncolor-index:检查设备颜色索引表中的颜色（他的值不能是负数），\nmonochrome:检测单色楨缓冲区域中的每个像素的位数（这个太高级，估计咱很少会用的到），\nresolution:检测屏幕或打印机的分辨率(例如：min-resolution:300dpi或min-resolution:118dpcm)，\ngrid：检测输出的设备是网格的还是位图设备。\n\n9.扩展——在CSS2中同样有媒体查询：\nmedia媒体查询并不是CSS3诞生之后的专用功能，早在CSS2开始就已经支持media，比如：\n在HTML文件中的<head></head>标签中写入这句：\n```\n<link rel=\"stylesheet\"type=\"text/css\" media=\"screen\"href=\"style.css\">\n```\n以上是CSS2实现的衬线用法，href属性中写入在某单一显示设备中链接的CSS文件，但仅供入门，\n如要判断移动设备是否为纵向放置的显示屏，可以这样写：\n```\n<link rel=\"stylesheet\" type=\"text/css\"media=\"screen and (orientation:portrait)\"href=\"style.css\">\n```\n如要让小于960px的页面执行指定的CSS样式文件，可以这样写：\n```\n<link rel=\"stylesheet\"type=\"text/css\" media=\"screen and (max-width:960px)\"href=\"style.css\">\n```\nCSS2中的媒体查询方法放到现在并不推荐使用，最大的弊端在于这样会增加页面http的请求次数，增加页面负担，使用CSS3中的媒体查询才是目前的最佳方法。\n\n---\n### 二.移动端rem适配\n---\n1.设计思路:\nrem是css3相对根节点(html)的字体大小的单位,通过设备宽度算出每个rem所对应的px,来实现动态适配.\n\n2.动态设置html的font-size,根据参照的设备宽度设置1rem = ?px;\n屏幕的总宽度即为(均分份数)16rem.\n```\nvar html = document.documentElement;\nvar width = html.getBoundingClientRect().width;     //设备尺寸绝对宽度(width = window.screen.width)\nhtml.style.fontSize = width / 16 + 'px';            //将屏幕分成16份：iphone5下（320/16） 1rem = 20px;\n//html.style.fontSize = width / 15 + 'px';          //将屏幕分成15份：iphone6下（375/15） 1rem = 25px;\n//html.style.fontSize = width / 18 + 'px';          //将屏幕分成15份：iphone6s调试\n```\n\n3.编写样式时,所有的尺寸单位均使用rem即可,实际开发中可使用编辑器的转换插件将px转成对应的rem值.\n\n---\n[【查看源码】](https://github.com/HoldCast/resposive)","source":"_posts/responseLayout.md","raw":"title: 响应式布局和移动端适配方案\ntags:\n  - 响应式\n  - 移动适配\n  - rem\n---\n前端响应式开发包括两个方向,web(pc)端的页面显示和移动端的页面显示,一般页面内容比较少,布局相对简单的页面可以直接采用媒体查询的方式来实现响应式;\n移动端和PC端需要展示不同的页面样式风格的页面,可以采用pc端响应式,移动端自动适配的方案.\n1.响应式布局 2.移动端适配-rem\n\n>不同的需求,采用不同的方案\n\n### 一.响应式布局\n1.设计思路：\n使用CSS3中媒体查询的大致思路就是判断网页在不同设备中所处的宽度范围，这样的范围可能有三种（PC、平板、手机），也可能有四种（PC、平板、中大屏手机、小屏手机），当然也可能只需要两种（平板、手机，PC端单独开发一版时可不作为CSS3媒体查询的使用对象），并为各种宽度范围情况下的所需页面元素套用不同的CSS样式，从而适配各种设备。\n\n<!-- more -->\n\n2.响应式网页开发中的宽度问题：\n在实际开发中，通常需要设置响应式网页宽度的最大值，一旦忽略最大宽度，臃肿或零散的网页布局都会造成视觉洪灾，也就是我们常说的看起来很low。\n目前最为常见的宽度基本上都是：大于或等于960px的PC端（1920px、1600px、1440px、1280px、1140px、960px）、960px至640px之间的平板端（768px、640px）以及640px以下的手机端（480px、320px），以上宽度存在已久，且显示设备中的网页宽度会长期处于这样的状态下，在响应式网页宽度设计上，基本从这几个尺寸考虑就已经足够。\n\n3.初始化设置：\n在HTML文件中，网页顶部<head></head>标签中插入一句话：\n```\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n这句话在于对响应式网页做一个初始化设置，主要包括：\nname=\"viewport\"：标记显示设备为视口；\nwidth = device-width：宽度等于当前设备的宽度；\ninitial-scale：初始的缩放比例（默认设置为1.0）；\nminimum-scale：允许用户缩放到的最小比例（默认设置为1.0）；\nmaximum-scale：允许用户缩放到的最大比例（默认设置为1.0）；\nuser-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）。\n\n4.解决IE浏览器的兼容性问题：\n因为IE浏览器(IE8)不支持HTML5和CSS3中的media，所以要加载用于解决IE浏览器兼容性问题的JS文件：\n```\n    <!--[if lt IE 9]>\n    <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n    <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n    <![endif]-->\n```\n两个<script></script>标签中的src属性所指向的文件链接地址为固定地址中的文件，直接异地引用就好，不用下载到本地引用。\n\n5.设置IE的渲染方式为最高：\n现在有很多人的IE浏览器都升级到IE9以上，这个时候会有很多诡异的事情发生，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8，为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新：\n```\n<meta http-equiv=\"X-UA-Compatible\"content=\"IE=edge\">\n```\n当然还有一个更给力的写法：\n```\n<meta http-equiv=\"X-UA-Compatible\"content=\"IE=Edge，chrome=1\">\n```\n这段代码后面加了一个chrome=1，这是由于Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果用户电脑安装这个chrome插件，就可让电脑内的IE浏览器规避版本因素，使用Webkit引擎及V8引擎进行排版及运算。当然如果用户没装这个插件，这段代码就会让IE浏览器以最高的文档模式展现效果。\n\n6.CSS3 media 媒体查询的写法：\n```\n@media screen and (max-width: 960px){body{background:#000;}}\n```\n这是一个media的标准写法，在CSS文件中，意为：当页面小于960px时执行以下CSS代码，具体内容暂不用管。\n对于上述代码中的screen，意为在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。目前很多网站都会直接省略screen,从而不需要考虑用户打印网页的需求，所以又有这种写法：\n```\n@media (max-width: 960px){\n    body{background:#000;}\n}\n```\n本着思维严谨的原则，一般不采用这种写法。\n\n7.CSS3媒体查询主体代码组合：\n在响应式网页布局中需要持续运用媒体查询代码组合，主要作用在于判断所适配屏幕的宽度，并根据各种宽度条件套用不同的CSS样式。\n- 如当屏幕宽度等于960px时，将网页背景色变为红色：\n```\n@media screen and (max-device-width:960px){\n    body{background:red;}\n}\n```\n\n- 如当屏幕宽度最大为960px（小于960px）时，将网页背景色变为黑色：\n```\n@media screen and (max-width: 960px){\n    body{background:#000;}\n}\n```\n\n- 如当屏幕宽度最小为960px（大于960px）时，将网页背景色变为桔色：\n```\n@media screen and (min-width:960px){\n    body{background:orange;}\n}\n```\n\n- 更为常见的是混合使用，如当屏幕宽度介于960px和1200px之间时，将网页背景色变为黄色：\n```\n@media screen and (min-width:960px) and(max-width:1200px){\n    body{background:yellow;}\n}\n```\n\n8.media媒体查询所有参数汇总：\n媒体查询器中还包含并不常用的相关功能，悉如示下：\nwidth:浏览器可视宽度，\nheight:浏览器可视高度，\ndevice-width:设备屏幕的宽度，\ndevice-height:设备屏幕的高度，\norientation:检测设备目前处于横向还是纵向状态，\naspect-ratio:检测浏览器可视宽度和高度的比例(例如：aspect-ratio:16/9)，\ndevice-aspect-ratio:检测设备的宽度和高度的比例，\ncolor:检测颜色的位数（例如：min-color:32就会检测设备是否拥有32位颜色），\ncolor-index:检查设备颜色索引表中的颜色（他的值不能是负数），\nmonochrome:检测单色楨缓冲区域中的每个像素的位数（这个太高级，估计咱很少会用的到），\nresolution:检测屏幕或打印机的分辨率(例如：min-resolution:300dpi或min-resolution:118dpcm)，\ngrid：检测输出的设备是网格的还是位图设备。\n\n9.扩展——在CSS2中同样有媒体查询：\nmedia媒体查询并不是CSS3诞生之后的专用功能，早在CSS2开始就已经支持media，比如：\n在HTML文件中的<head></head>标签中写入这句：\n```\n<link rel=\"stylesheet\"type=\"text/css\" media=\"screen\"href=\"style.css\">\n```\n以上是CSS2实现的衬线用法，href属性中写入在某单一显示设备中链接的CSS文件，但仅供入门，\n如要判断移动设备是否为纵向放置的显示屏，可以这样写：\n```\n<link rel=\"stylesheet\" type=\"text/css\"media=\"screen and (orientation:portrait)\"href=\"style.css\">\n```\n如要让小于960px的页面执行指定的CSS样式文件，可以这样写：\n```\n<link rel=\"stylesheet\"type=\"text/css\" media=\"screen and (max-width:960px)\"href=\"style.css\">\n```\nCSS2中的媒体查询方法放到现在并不推荐使用，最大的弊端在于这样会增加页面http的请求次数，增加页面负担，使用CSS3中的媒体查询才是目前的最佳方法。\n\n---\n### 二.移动端rem适配\n---\n1.设计思路:\nrem是css3相对根节点(html)的字体大小的单位,通过设备宽度算出每个rem所对应的px,来实现动态适配.\n\n2.动态设置html的font-size,根据参照的设备宽度设置1rem = ?px;\n屏幕的总宽度即为(均分份数)16rem.\n```\nvar html = document.documentElement;\nvar width = html.getBoundingClientRect().width;     //设备尺寸绝对宽度(width = window.screen.width)\nhtml.style.fontSize = width / 16 + 'px';            //将屏幕分成16份：iphone5下（320/16） 1rem = 20px;\n//html.style.fontSize = width / 15 + 'px';          //将屏幕分成15份：iphone6下（375/15） 1rem = 25px;\n//html.style.fontSize = width / 18 + 'px';          //将屏幕分成15份：iphone6s调试\n```\n\n3.编写样式时,所有的尺寸单位均使用rem即可,实际开发中可使用编辑器的转换插件将px转成对应的rem值.\n\n---\n[【查看源码】](https://github.com/HoldCast/resposive)","slug":"responseLayout","published":1,"date":"2018-11-19T09:04:19.960Z","updated":"2018-11-19T09:04:19.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bwq0008natfbpj99ked","content":"<p>前端响应式开发包括两个方向,web(pc)端的页面显示和移动端的页面显示,一般页面内容比较少,布局相对简单的页面可以直接采用媒体查询的方式来实现响应式;<br>移动端和PC端需要展示不同的页面样式风格的页面,可以采用pc端响应式,移动端自动适配的方案.<br>1.响应式布局 2.移动端适配-rem</p>\n<blockquote>\n<p>不同的需求,采用不同的方案</p>\n</blockquote>\n<h3 id=\"一-响应式布局\"><a href=\"#一-响应式布局\" class=\"headerlink\" title=\"一.响应式布局\"></a>一.响应式布局</h3><p>1.设计思路：<br>使用CSS3中媒体查询的大致思路就是判断网页在不同设备中所处的宽度范围，这样的范围可能有三种（PC、平板、手机），也可能有四种（PC、平板、中大屏手机、小屏手机），当然也可能只需要两种（平板、手机，PC端单独开发一版时可不作为CSS3媒体查询的使用对象），并为各种宽度范围情况下的所需页面元素套用不同的CSS样式，从而适配各种设备。</p>\n<a id=\"more\"></a>\n<p>2.响应式网页开发中的宽度问题：<br>在实际开发中，通常需要设置响应式网页宽度的最大值，一旦忽略最大宽度，臃肿或零散的网页布局都会造成视觉洪灾，也就是我们常说的看起来很low。<br>目前最为常见的宽度基本上都是：大于或等于960px的PC端（1920px、1600px、1440px、1280px、1140px、960px）、960px至640px之间的平板端（768px、640px）以及640px以下的手机端（480px、320px），以上宽度存在已久，且显示设备中的网页宽度会长期处于这样的状态下，在响应式网页宽度设计上，基本从这几个尺寸考虑就已经足够。</p>\n<p>3.初始化设置：<br>在HTML文件中，网页顶部<head><meta name=\"generator\" content=\"Hexo 3.8.0\"></head>标签中插入一句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这句话在于对响应式网页做一个初始化设置，主要包括：<br>name=”viewport”：标记显示设备为视口；<br>width = device-width：宽度等于当前设备的宽度；<br>initial-scale：初始的缩放比例（默认设置为1.0）；<br>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）；<br>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）；<br>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）。</p>\n<p>4.解决IE浏览器的兼容性问题：<br>因为IE浏览器(IE8)不支持HTML5和CSS3中的media，所以要加载用于解决IE浏览器兼容性问题的JS文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--[if lt IE 9]&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p>\n<p>两个<script></script>标签中的src属性所指向的文件链接地址为固定地址中的文件，直接异地引用就好，不用下载到本地引用。</p>\n<p>5.设置IE的渲染方式为最高：<br>现在有很多人的IE浏览器都升级到IE9以上，这个时候会有很多诡异的事情发生，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8，为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot;content=&quot;IE=edge&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当然还有一个更给力的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot;content=&quot;IE=Edge，chrome=1&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码后面加了一个chrome=1，这是由于Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果用户电脑安装这个chrome插件，就可让电脑内的IE浏览器规避版本因素，使用Webkit引擎及V8引擎进行排版及运算。当然如果用户没装这个插件，这段代码就会让IE浏览器以最高的文档模式展现效果。</p>\n<p>6.CSS3 media 媒体查询的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 960px)&#123;body&#123;background:#000;&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个media的标准写法，在CSS文件中，意为：当页面小于960px时执行以下CSS代码，具体内容暂不用管。<br>对于上述代码中的screen，意为在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。目前很多网站都会直接省略screen,从而不需要考虑用户打印网页的需求，所以又有这种写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (max-width: 960px)&#123;</span><br><span class=\"line\">    body&#123;background:#000;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本着思维严谨的原则，一般不采用这种写法。</p>\n<p>7.CSS3媒体查询主体代码组合：<br>在响应式网页布局中需要持续运用媒体查询代码组合，主要作用在于判断所适配屏幕的宽度，并根据各种宽度条件套用不同的CSS样式。</p>\n<ul>\n<li><p>如当屏幕宽度等于960px时，将网页背景色变为红色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-device-width:960px)&#123;</span><br><span class=\"line\">    body&#123;background:red;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如当屏幕宽度最大为960px（小于960px）时，将网页背景色变为黑色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 960px)&#123;</span><br><span class=\"line\">    body&#123;background:#000;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如当屏幕宽度最小为960px（大于960px）时，将网页背景色变为桔色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width:960px)&#123;</span><br><span class=\"line\">    body&#123;background:orange;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更为常见的是混合使用，如当屏幕宽度介于960px和1200px之间时，将网页背景色变为黄色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width:960px) and(max-width:1200px)&#123;</span><br><span class=\"line\">    body&#123;background:yellow;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>8.media媒体查询所有参数汇总：<br>媒体查询器中还包含并不常用的相关功能，悉如示下：<br>width:浏览器可视宽度，<br>height:浏览器可视高度，<br>device-width:设备屏幕的宽度，<br>device-height:设备屏幕的高度，<br>orientation:检测设备目前处于横向还是纵向状态，<br>aspect-ratio:检测浏览器可视宽度和高度的比例(例如：aspect-ratio:16/9)，<br>device-aspect-ratio:检测设备的宽度和高度的比例，<br>color:检测颜色的位数（例如：min-color:32就会检测设备是否拥有32位颜色），<br>color-index:检查设备颜色索引表中的颜色（他的值不能是负数），<br>monochrome:检测单色楨缓冲区域中的每个像素的位数（这个太高级，估计咱很少会用的到），<br>resolution:检测屏幕或打印机的分辨率(例如：min-resolution:300dpi或min-resolution:118dpcm)，<br>grid：检测输出的设备是网格的还是位图设备。</p>\n<p>9.扩展——在CSS2中同样有媒体查询：<br>media媒体查询并不是CSS3诞生之后的专用功能，早在CSS2开始就已经支持media，比如：<br>在HTML文件中的<head><meta name=\"generator\" content=\"Hexo 3.8.0\"></head>标签中写入这句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; media=&quot;screen&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以上是CSS2实现的衬线用法，href属性中写入在某单一显示设备中链接的CSS文件，但仅供入门，<br>如要判断移动设备是否为纵向放置的显示屏，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;media=&quot;screen and (orientation:portrait)&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如要让小于960px的页面执行指定的CSS样式文件，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; media=&quot;screen and (max-width:960px)&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS2中的媒体查询方法放到现在并不推荐使用，最大的弊端在于这样会增加页面http的请求次数，增加页面负担，使用CSS3中的媒体查询才是目前的最佳方法。</p>\n<hr>\n<h3 id=\"二-移动端rem适配\"><a href=\"#二-移动端rem适配\" class=\"headerlink\" title=\"二.移动端rem适配\"></a>二.移动端rem适配</h3><hr>\n<p>1.设计思路:<br>rem是css3相对根节点(html)的字体大小的单位,通过设备宽度算出每个rem所对应的px,来实现动态适配.</p>\n<p>2.动态设置html的font-size,根据参照的设备宽度设置1rem = ?px;<br>屏幕的总宽度即为(均分份数)16rem.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var html = document.documentElement;</span><br><span class=\"line\">var width = html.getBoundingClientRect().width;     //设备尺寸绝对宽度(width = window.screen.width)</span><br><span class=\"line\">html.style.fontSize = width / 16 + &apos;px&apos;;            //将屏幕分成16份：iphone5下（320/16） 1rem = 20px;</span><br><span class=\"line\">//html.style.fontSize = width / 15 + &apos;px&apos;;          //将屏幕分成15份：iphone6下（375/15） 1rem = 25px;</span><br><span class=\"line\">//html.style.fontSize = width / 18 + &apos;px&apos;;          //将屏幕分成15份：iphone6s调试</span><br></pre></td></tr></table></figure></p>\n<p>3.编写样式时,所有的尺寸单位均使用rem即可,实际开发中可使用编辑器的转换插件将px转成对应的rem值.</p>\n<hr>\n<p><a href=\"https://github.com/HoldCast/resposive\" target=\"_blank\" rel=\"noopener\">【查看源码】</a></p>\n","site":{"data":{}},"excerpt":"<p>前端响应式开发包括两个方向,web(pc)端的页面显示和移动端的页面显示,一般页面内容比较少,布局相对简单的页面可以直接采用媒体查询的方式来实现响应式;<br>移动端和PC端需要展示不同的页面样式风格的页面,可以采用pc端响应式,移动端自动适配的方案.<br>1.响应式布局 2.移动端适配-rem</p>\n<blockquote>\n<p>不同的需求,采用不同的方案</p>\n</blockquote>\n<h3 id=\"一-响应式布局\"><a href=\"#一-响应式布局\" class=\"headerlink\" title=\"一.响应式布局\"></a>一.响应式布局</h3><p>1.设计思路：<br>使用CSS3中媒体查询的大致思路就是判断网页在不同设备中所处的宽度范围，这样的范围可能有三种（PC、平板、手机），也可能有四种（PC、平板、中大屏手机、小屏手机），当然也可能只需要两种（平板、手机，PC端单独开发一版时可不作为CSS3媒体查询的使用对象），并为各种宽度范围情况下的所需页面元素套用不同的CSS样式，从而适配各种设备。</p>","more":"<p>2.响应式网页开发中的宽度问题：<br>在实际开发中，通常需要设置响应式网页宽度的最大值，一旦忽略最大宽度，臃肿或零散的网页布局都会造成视觉洪灾，也就是我们常说的看起来很low。<br>目前最为常见的宽度基本上都是：大于或等于960px的PC端（1920px、1600px、1440px、1280px、1140px、960px）、960px至640px之间的平板端（768px、640px）以及640px以下的手机端（480px、320px），以上宽度存在已久，且显示设备中的网页宽度会长期处于这样的状态下，在响应式网页宽度设计上，基本从这几个尺寸考虑就已经足够。</p>\n<p>3.初始化设置：<br>在HTML文件中，网页顶部<head><meta name=\"generator\" content=\"Hexo 3.8.0\"></head>标签中插入一句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这句话在于对响应式网页做一个初始化设置，主要包括：<br>name=”viewport”：标记显示设备为视口；<br>width = device-width：宽度等于当前设备的宽度；<br>initial-scale：初始的缩放比例（默认设置为1.0）；<br>minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）；<br>maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）；<br>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）。</p>\n<p>4.解决IE浏览器的兼容性问题：<br>因为IE浏览器(IE8)不支持HTML5和CSS3中的media，所以要加载用于解决IE浏览器兼容性问题的JS文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--[if lt IE 9]&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></p>\n<p>两个<script></script>标签中的src属性所指向的文件链接地址为固定地址中的文件，直接异地引用就好，不用下载到本地引用。</p>\n<p>5.设置IE的渲染方式为最高：<br>现在有很多人的IE浏览器都升级到IE9以上，这个时候会有很多诡异的事情发生，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8，为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot;content=&quot;IE=edge&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当然还有一个更给力的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;X-UA-Compatible&quot;content=&quot;IE=Edge，chrome=1&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码后面加了一个chrome=1，这是由于Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果用户电脑安装这个chrome插件，就可让电脑内的IE浏览器规避版本因素，使用Webkit引擎及V8引擎进行排版及运算。当然如果用户没装这个插件，这段代码就会让IE浏览器以最高的文档模式展现效果。</p>\n<p>6.CSS3 media 媒体查询的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 960px)&#123;body&#123;background:#000;&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是一个media的标准写法，在CSS文件中，意为：当页面小于960px时执行以下CSS代码，具体内容暂不用管。<br>对于上述代码中的screen，意为在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。目前很多网站都会直接省略screen,从而不需要考虑用户打印网页的需求，所以又有这种写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (max-width: 960px)&#123;</span><br><span class=\"line\">    body&#123;background:#000;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本着思维严谨的原则，一般不采用这种写法。</p>\n<p>7.CSS3媒体查询主体代码组合：<br>在响应式网页布局中需要持续运用媒体查询代码组合，主要作用在于判断所适配屏幕的宽度，并根据各种宽度条件套用不同的CSS样式。</p>\n<ul>\n<li><p>如当屏幕宽度等于960px时，将网页背景色变为红色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-device-width:960px)&#123;</span><br><span class=\"line\">    body&#123;background:red;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如当屏幕宽度最大为960px（小于960px）时，将网页背景色变为黑色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (max-width: 960px)&#123;</span><br><span class=\"line\">    body&#123;background:#000;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如当屏幕宽度最小为960px（大于960px）时，将网页背景色变为桔色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width:960px)&#123;</span><br><span class=\"line\">    body&#123;background:orange;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更为常见的是混合使用，如当屏幕宽度介于960px和1200px之间时，将网页背景色变为黄色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width:960px) and(max-width:1200px)&#123;</span><br><span class=\"line\">    body&#123;background:yellow;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>8.media媒体查询所有参数汇总：<br>媒体查询器中还包含并不常用的相关功能，悉如示下：<br>width:浏览器可视宽度，<br>height:浏览器可视高度，<br>device-width:设备屏幕的宽度，<br>device-height:设备屏幕的高度，<br>orientation:检测设备目前处于横向还是纵向状态，<br>aspect-ratio:检测浏览器可视宽度和高度的比例(例如：aspect-ratio:16/9)，<br>device-aspect-ratio:检测设备的宽度和高度的比例，<br>color:检测颜色的位数（例如：min-color:32就会检测设备是否拥有32位颜色），<br>color-index:检查设备颜色索引表中的颜色（他的值不能是负数），<br>monochrome:检测单色楨缓冲区域中的每个像素的位数（这个太高级，估计咱很少会用的到），<br>resolution:检测屏幕或打印机的分辨率(例如：min-resolution:300dpi或min-resolution:118dpcm)，<br>grid：检测输出的设备是网格的还是位图设备。</p>\n<p>9.扩展——在CSS2中同样有媒体查询：<br>media媒体查询并不是CSS3诞生之后的专用功能，早在CSS2开始就已经支持media，比如：<br>在HTML文件中的<head><meta name=\"generator\" content=\"Hexo 3.8.0\"></head>标签中写入这句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; media=&quot;screen&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>以上是CSS2实现的衬线用法，href属性中写入在某单一显示设备中链接的CSS文件，但仅供入门，<br>如要判断移动设备是否为纵向放置的显示屏，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;media=&quot;screen and (orientation:portrait)&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如要让小于960px的页面执行指定的CSS样式文件，可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; media=&quot;screen and (max-width:960px)&quot;href=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS2中的媒体查询方法放到现在并不推荐使用，最大的弊端在于这样会增加页面http的请求次数，增加页面负担，使用CSS3中的媒体查询才是目前的最佳方法。</p>\n<hr>\n<h3 id=\"二-移动端rem适配\"><a href=\"#二-移动端rem适配\" class=\"headerlink\" title=\"二.移动端rem适配\"></a>二.移动端rem适配</h3><hr>\n<p>1.设计思路:<br>rem是css3相对根节点(html)的字体大小的单位,通过设备宽度算出每个rem所对应的px,来实现动态适配.</p>\n<p>2.动态设置html的font-size,根据参照的设备宽度设置1rem = ?px;<br>屏幕的总宽度即为(均分份数)16rem.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var html = document.documentElement;</span><br><span class=\"line\">var width = html.getBoundingClientRect().width;     //设备尺寸绝对宽度(width = window.screen.width)</span><br><span class=\"line\">html.style.fontSize = width / 16 + &apos;px&apos;;            //将屏幕分成16份：iphone5下（320/16） 1rem = 20px;</span><br><span class=\"line\">//html.style.fontSize = width / 15 + &apos;px&apos;;          //将屏幕分成15份：iphone6下（375/15） 1rem = 25px;</span><br><span class=\"line\">//html.style.fontSize = width / 18 + &apos;px&apos;;          //将屏幕分成15份：iphone6s调试</span><br></pre></td></tr></table></figure></p>\n<p>3.编写样式时,所有的尺寸单位均使用rem即可,实际开发中可使用编辑器的转换插件将px转成对应的rem值.</p>\n<hr>\n<p><a href=\"https://github.com/HoldCast/resposive\" target=\"_blank\" rel=\"noopener\">【查看源码】</a></p>"},{"title":"HTTP协议 - HyperText Transfer Protocol，超文本传输协议","_content":">因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### 工作原理\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\nWeb服务器有：Apache服务器，IIS服务器（Internet Information Services）等。\nWeb服务器根据接收到的请求后，向客户端发送响应信息。\nHTTP默认端口号为80，但是你也可以改为8080或者其他端口。\n#### HTTP - 三点注意事项：\n- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)\n- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n  HTTP协议通信流程：\n![](/assets/img/http-lc.png)\n(Common Gateway Interface，简称CGI)\n\n<!-- more -->\n### 请求方法\n根据HTTP标准，HTTP请求可以使用多种请求方法。\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n1.GET\t请求指定的页面信息，并返回实体主体。\n2.HEAD\t类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3.POST\t向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4.PUT\t从客户端向服务器传送的数据取代指定的文档的内容。\n5.DELETE\t请求服务器删除指定的页面。\n6.CONNECT\tHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7.OPTIONS\t允许客户端查看服务器的性能。\n8.TRACE\t回显服务器收到的请求，主要用于测试或诊断。\n\n### 响应头信息\n- Allow 服务器支持哪些请求方法（如GET、POST等）。\n- Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\n- Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\n- Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\n- Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\n- Expires 应该在什么时候认为文档已经过期，从而不再缓存它？\n- Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\n- Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\n- Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=<span>http://host/path</span>\")让浏览器读取指定的页面。\n  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"</pre>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。\n  注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。\n  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\n- Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\n- Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\n- WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。\n  注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n","source":"_posts/websoket.md","raw":"title: HTTP协议 - HyperText Transfer Protocol，超文本传输协议\ntags:\n    - http\n---\n>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### 工作原理\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。\nWeb服务器有：Apache服务器，IIS服务器（Internet Information Services）等。\nWeb服务器根据接收到的请求后，向客户端发送响应信息。\nHTTP默认端口号为80，但是你也可以改为8080或者其他端口。\n#### HTTP - 三点注意事项：\n- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)\n- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n  HTTP协议通信流程：\n![](/assets/img/http-lc.png)\n(Common Gateway Interface，简称CGI)\n\n<!-- more -->\n### 请求方法\n根据HTTP标准，HTTP请求可以使用多种请求方法。\nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n1.GET\t请求指定的页面信息，并返回实体主体。\n2.HEAD\t类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3.POST\t向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4.PUT\t从客户端向服务器传送的数据取代指定的文档的内容。\n5.DELETE\t请求服务器删除指定的页面。\n6.CONNECT\tHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7.OPTIONS\t允许客户端查看服务器的性能。\n8.TRACE\t回显服务器收到的请求，主要用于测试或诊断。\n\n### 响应头信息\n- Allow 服务器支持哪些请求方法（如GET、POST等）。\n- Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\n- Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\n- Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\n- Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\n- Expires 应该在什么时候认为文档已经过期，从而不再缓存它？\n- Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\n- Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\n- Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=<span>http://host/path</span>\")让浏览器读取指定的页面。\n  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"</pre>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。\n  注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。\n  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\n- Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\n- Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\n- WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。\n  注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n","slug":"websoket","published":1,"date":"2018-11-19T09:04:19.000Z","updated":"2018-11-19T09:04:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bwr000anatfgz0zxwle","content":"<blockquote>\n<p>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n</blockquote>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>\n<h4 id=\"HTTP-三点注意事项：\"><a href=\"#HTTP-三点注意事项：\" class=\"headerlink\" title=\"HTTP - 三点注意事项：\"></a>HTTP - 三点注意事项：</h4><ul>\n<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>\n<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)</li>\n<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>HTTP协议通信流程：<br><img src=\"/assets/img/http-lc.png\" alt=\"\"><br>(Common Gateway Interface，简称CGI)</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>1.GET    请求指定的页面信息，并返回实体主体。<br>2.HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3.POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>4.PUT    从客户端向服务器传送的数据取代指定的文档的内容。<br>5.DELETE    请求服务器删除指定的页面。<br>6.CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>7.OPTIONS    允许客户端查看服务器的性能。<br>8.TRACE    回显服务器收到的请求，主要用于测试或诊断。</p>\n<h3 id=\"响应头信息\"><a href=\"#响应头信息\" class=\"headerlink\" title=\"响应头信息\"></a>响应头信息</h3><ul>\n<li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li>\n<li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li>\n<li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>\n<li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</li>\n<li>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>\n<li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li>\n<li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li>\n<li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li>\n<li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<span><a href=\"http://host/path\" target=\"_blank\" rel=\"noopener\">http://host/path</a></span>“)让浏览器读取指定的页面。<br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;\" target=\"_blank\" rel=\"noopener\">http://host/path&quot;</a>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。<br>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。<br>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li>\n<li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li>\n<li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</li>\n<li>WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n</blockquote>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>\n<h4 id=\"HTTP-三点注意事项：\"><a href=\"#HTTP-三点注意事项：\" class=\"headerlink\" title=\"HTTP - 三点注意事项：\"></a>HTTP - 三点注意事项：</h4><ul>\n<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>\n<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。(多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）)</li>\n<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>HTTP协议通信流程：<br><img src=\"/assets/img/http-lc.png\" alt=\"\"><br>(Common Gateway Interface，简称CGI)</li>\n</ul>","more":"<h3 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h3><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>1.GET    请求指定的页面信息，并返回实体主体。<br>2.HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3.POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>4.PUT    从客户端向服务器传送的数据取代指定的文档的内容。<br>5.DELETE    请求服务器删除指定的页面。<br>6.CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>7.OPTIONS    允许客户端查看服务器的性能。<br>8.TRACE    回显服务器收到的请求，主要用于测试或诊断。</p>\n<h3 id=\"响应头信息\"><a href=\"#响应头信息\" class=\"headerlink\" title=\"响应头信息\"></a>响应头信息</h3><ul>\n<li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li>\n<li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li>\n<li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>\n<li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</li>\n<li>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>\n<li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li>\n<li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li>\n<li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li>\n<li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<span><a href=\"http://host/path\" target=\"_blank\" rel=\"noopener\">http://host/path</a></span>“)让浏览器读取指定的页面。<br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;\" target=\"_blank\" rel=\"noopener\">http://host/path&quot;</a>＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。<br>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。<br>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li>\n<li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li>\n<li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</li>\n<li>WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</li>\n</ul>"},{"title":"Websocket协议调试","_content":">使用websocket协议 + nodeJS实现即时通讯\n\n### 1.websocket + nodejS\n* 1)到websocket目录下安装依赖:npm install --save-dev nodejs-websocket\n* 2)运行 node websocketServer.js\n* 3)同时打开sendMessage.hrml 和 getMessage.html, 分别发送消息和接收消息\n### 2.socket.io + nodeJS\n* 1)到socket.io目录下安装依赖项: npm install --save-dev express socket.io\n* 2)运行 node socketIoServer.js\n* 3)页面打开socket.io.html (在多个终端下打开,测试同步性)\n* 4)socket.io.html注意引用socket.io模块中的socket.io.js\n### 3.相关资料\n* 1）[【websocket测试代码】](https://github.com/HoldCast/websocket)\n\n* 2）[【websocket协议原理说明】](https://www.zhihu.com/question/20215561)\n","source":"_posts/websocket.md","raw":"title: Websocket协议调试\ntags:\n    - websocket nodejs\n---\n>使用websocket协议 + nodeJS实现即时通讯\n\n### 1.websocket + nodejS\n* 1)到websocket目录下安装依赖:npm install --save-dev nodejs-websocket\n* 2)运行 node websocketServer.js\n* 3)同时打开sendMessage.hrml 和 getMessage.html, 分别发送消息和接收消息\n### 2.socket.io + nodeJS\n* 1)到socket.io目录下安装依赖项: npm install --save-dev express socket.io\n* 2)运行 node socketIoServer.js\n* 3)页面打开socket.io.html (在多个终端下打开,测试同步性)\n* 4)socket.io.html注意引用socket.io模块中的socket.io.js\n### 3.相关资料\n* 1）[【websocket测试代码】](https://github.com/HoldCast/websocket)\n\n* 2）[【websocket协议原理说明】](https://www.zhihu.com/question/20215561)\n","slug":"websocket","published":1,"date":"2018-11-19T09:18:41.044Z","updated":"2018-11-19T09:18:41.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoo58bws000cnatfkdkzodj3","content":"<blockquote>\n<p>使用websocket协议 + nodeJS实现即时通讯</p>\n</blockquote>\n<h3 id=\"1-websocket-nodejS\"><a href=\"#1-websocket-nodejS\" class=\"headerlink\" title=\"1.websocket + nodejS\"></a>1.websocket + nodejS</h3><ul>\n<li>1)到websocket目录下安装依赖:npm install –save-dev nodejs-websocket</li>\n<li>2)运行 node websocketServer.js</li>\n<li>3)同时打开sendMessage.hrml 和 getMessage.html, 分别发送消息和接收消息<h3 id=\"2-socket-io-nodeJS\"><a href=\"#2-socket-io-nodeJS\" class=\"headerlink\" title=\"2.socket.io + nodeJS\"></a>2.socket.io + nodeJS</h3></li>\n<li>1)到socket.io目录下安装依赖项: npm install –save-dev express socket.io</li>\n<li>2)运行 node socketIoServer.js</li>\n<li>3)页面打开socket.io.html (在多个终端下打开,测试同步性)</li>\n<li>4)socket.io.html注意引用socket.io模块中的socket.io.js<h3 id=\"3-相关资料\"><a href=\"#3-相关资料\" class=\"headerlink\" title=\"3.相关资料\"></a>3.相关资料</h3></li>\n<li><p>1）<a href=\"https://github.com/HoldCast/websocket\" target=\"_blank\" rel=\"noopener\">【websocket测试代码】</a></p>\n</li>\n<li><p>2）<a href=\"https://www.zhihu.com/question/20215561\" target=\"_blank\" rel=\"noopener\">【websocket协议原理说明】</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>使用websocket协议 + nodeJS实现即时通讯</p>\n</blockquote>\n<h3 id=\"1-websocket-nodejS\"><a href=\"#1-websocket-nodejS\" class=\"headerlink\" title=\"1.websocket + nodejS\"></a>1.websocket + nodejS</h3><ul>\n<li>1)到websocket目录下安装依赖:npm install –save-dev nodejs-websocket</li>\n<li>2)运行 node websocketServer.js</li>\n<li>3)同时打开sendMessage.hrml 和 getMessage.html, 分别发送消息和接收消息<h3 id=\"2-socket-io-nodeJS\"><a href=\"#2-socket-io-nodeJS\" class=\"headerlink\" title=\"2.socket.io + nodeJS\"></a>2.socket.io + nodeJS</h3></li>\n<li>1)到socket.io目录下安装依赖项: npm install –save-dev express socket.io</li>\n<li>2)运行 node socketIoServer.js</li>\n<li>3)页面打开socket.io.html (在多个终端下打开,测试同步性)</li>\n<li>4)socket.io.html注意引用socket.io模块中的socket.io.js<h3 id=\"3-相关资料\"><a href=\"#3-相关资料\" class=\"headerlink\" title=\"3.相关资料\"></a>3.相关资料</h3></li>\n<li><p>1）<a href=\"https://github.com/HoldCast/websocket\" target=\"_blank\" rel=\"noopener\">【websocket测试代码】</a></p>\n</li>\n<li><p>2）<a href=\"https://www.zhihu.com/question/20215561\" target=\"_blank\" rel=\"noopener\">【websocket协议原理说明】</a></p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjoo58bwe0000natf7ay3wby6","tag_id":"cjoo58bwk0002natfkveqwzni","_id":"cjoo58bws000bnatfe24xji4l"},{"post_id":"cjoo58bwe0000natf7ay3wby6","tag_id":"cjoo58bwo0006natftp45ouln","_id":"cjoo58bwu000dnatf9fqd6osz"},{"post_id":"cjoo58bwi0001natfby3p2joy","tag_id":"cjoo58bwq0009natfe41nnu14","_id":"cjoo58bwu000fnatfkt3lyfvl"},{"post_id":"cjoo58bwm0003natf95f8w7qk","tag_id":"cjoo58bwu000enatfa5cb77xx","_id":"cjoo58bwv000jnatfq2yjqlfy"},{"post_id":"cjoo58bwm0003natf95f8w7qk","tag_id":"cjoo58bwu000gnatfuod30oa2","_id":"cjoo58bwv000knatfnaq9elem"},{"post_id":"cjoo58bwm0003natf95f8w7qk","tag_id":"cjoo58bwv000hnatfahzm65zy","_id":"cjoo58bwv000mnatffu0gvd3k"},{"post_id":"cjoo58bwn0004natfdr6te2de","tag_id":"cjoo58bwv000inatf419hbei8","_id":"cjoo58bwx000pnatf3c4lx0wp"},{"post_id":"cjoo58bwn0004natfdr6te2de","tag_id":"cjoo58bwv000lnatfklflm8iw","_id":"cjoo58bwx000qnatf76f3den2"},{"post_id":"cjoo58bwn0004natfdr6te2de","tag_id":"cjoo58bwv000nnatfxm5hoasi","_id":"cjoo58bwx000snatfgokf1fuq"},{"post_id":"cjoo58bwo0005natfig6ob6jx","tag_id":"cjoo58bwu000enatfa5cb77xx","_id":"cjoo58bwy000unatf94xgc740"},{"post_id":"cjoo58bwo0005natfig6ob6jx","tag_id":"cjoo58bwx000rnatfa9f5iebg","_id":"cjoo58bwy000vnatfmg9vm4jy"},{"post_id":"cjoo58bwp0007natfgdcozam6","tag_id":"cjoo58bwu000enatfa5cb77xx","_id":"cjoo58bwz000xnatfuov66ffv"},{"post_id":"cjoo58bwq0008natfbpj99ked","tag_id":"cjoo58bwv000lnatfklflm8iw","_id":"cjoo58bx00011natfw1vkv17l"},{"post_id":"cjoo58bwq0008natfbpj99ked","tag_id":"cjoo58bwz000ynatffjg2vqaw","_id":"cjoo58bx00012natf469ke07w"},{"post_id":"cjoo58bwq0008natfbpj99ked","tag_id":"cjoo58bwz000znatfdkz04jhs","_id":"cjoo58bx00014natfco1zqgrs"},{"post_id":"cjoo58bwr000anatfgz0zxwle","tag_id":"cjoo58bwu000enatfa5cb77xx","_id":"cjoo58bx00015natf5a6k3tpt"},{"post_id":"cjoo58bws000cnatfkdkzodj3","tag_id":"cjoo58bx00013natf9e4zx6y9","_id":"cjoo58bx00016natf8gi3r5tn"}],"Tag":[{"name":"javascript","_id":"cjoo58bwk0002natfkveqwzni"},{"name":"类型判断","_id":"cjoo58bwo0006natftp45ouln"},{"name":"guide","_id":"cjoo58bwq0009natfe41nnu14"},{"name":"http","_id":"cjoo58bwu000enatfa5cb77xx"},{"name":"header","_id":"cjoo58bwu000gnatfuod30oa2"},{"name":"服务器时间","_id":"cjoo58bwv000hnatfahzm65zy"},{"name":"bootstrap","_id":"cjoo58bwv000inatf419hbei8"},{"name":"响应式","_id":"cjoo58bwv000lnatfklflm8iw"},{"name":"metro","_id":"cjoo58bwv000nnatfxm5hoasi"},{"name":"状态码","_id":"cjoo58bwx000rnatfa9f5iebg"},{"name":"移动适配","_id":"cjoo58bwz000ynatffjg2vqaw"},{"name":"rem","_id":"cjoo58bwz000znatfdkz04jhs"},{"name":"websocket nodejs","_id":"cjoo58bx00013natf9e4zx6y9"}]}}